// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: introspection.proto

package introspection_pb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// The status of a connection or stream.
type Status int32

const (
	Status_ACTIVE  Status = 0
	Status_CLOSED  Status = 1
	Status_OPENING Status = 2
	Status_CLOSING Status = 3
	Status_ERROR   Status = 4
)

var Status_name = map[int32]string{
	0: "ACTIVE",
	1: "CLOSED",
	2: "OPENING",
	3: "CLOSING",
	4: "ERROR",
}

var Status_value = map[string]int32{
	"ACTIVE":  0,
	"CLOSED":  1,
	"OPENING": 2,
	"CLOSING": 3,
	"ERROR":   4,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{0}
}

// Our role in a connection or stream.
type Role int32

const (
	Role_INITIATOR Role = 0
	Role_RESPONDER Role = 1
)

var Role_name = map[int32]string{
	0: "INITIATOR",
	1: "RESPONDER",
}

var Role_value = map[string]int32{
	"INITIATOR": 0,
	"RESPONDER": 1,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}

func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{1}
}

// Trigger of the query.
type DHT_Query_Trigger int32

const (
	DHT_Query_API       DHT_Query_Trigger = 0
	DHT_Query_DISCOVERY DHT_Query_Trigger = 1
)

var DHT_Query_Trigger_name = map[int32]string{
	0: "API",
	1: "DISCOVERY",
}

var DHT_Query_Trigger_value = map[string]int32{
	"API":       0,
	"DISCOVERY": 1,
}

func (x DHT_Query_Trigger) String() string {
	return proto.EnumName(DHT_Query_Trigger_name, int32(x))
}

func (DHT_Query_Trigger) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{10, 1, 0}
}

// Type of the query.
type DHT_Query_Type int32

const (
	DHT_Query_CONTENT  DHT_Query_Type = 0
	DHT_Query_PROVIDER DHT_Query_Type = 1
	DHT_Query_VALUE    DHT_Query_Type = 2
)

var DHT_Query_Type_name = map[int32]string{
	0: "CONTENT",
	1: "PROVIDER",
	2: "VALUE",
}

var DHT_Query_Type_value = map[string]int32{
	"CONTENT":  0,
	"PROVIDER": 1,
	"VALUE":    2,
}

func (x DHT_Query_Type) String() string {
	return proto.EnumName(DHT_Query_Type_name, int32(x))
}

func (DHT_Query_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{10, 1, 1}
}

// Status indicating the result of the query
type DHT_Query_Result int32

const (
	DHT_Query_SUCCESS DHT_Query_Result = 0
	DHT_Query_ERROR   DHT_Query_Result = 1
	DHT_Query_TIMEOUT DHT_Query_Result = 2
	// Pending queries may be absent, depending on data collection
	DHT_Query_PENDING DHT_Query_Result = 3
)

var DHT_Query_Result_name = map[int32]string{
	0: "SUCCESS",
	1: "ERROR",
	2: "TIMEOUT",
	3: "PENDING",
}

var DHT_Query_Result_value = map[string]int32{
	"SUCCESS": 0,
	"ERROR":   1,
	"TIMEOUT": 2,
	"PENDING": 3,
}

func (x DHT_Query_Result) String() string {
	return proto.EnumName(DHT_Query_Result_name, int32(x))
}

func (DHT_Query_Result) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{10, 1, 2}
}

// Version of schema
type Version struct {
	Number uint32 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{0}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// ResultCounter is a monotonically increasing counter that reports an ok/err breakdown of the total.
type ResultCounter struct {
	Total uint32 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Ok    uint32 `protobuf:"varint,2,opt,name=ok,proto3" json:"ok,omitempty"`
	Err   uint32 `protobuf:"varint,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *ResultCounter) Reset()         { *m = ResultCounter{} }
func (m *ResultCounter) String() string { return proto.CompactTextString(m) }
func (*ResultCounter) ProtoMessage()    {}
func (*ResultCounter) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{1}
}
func (m *ResultCounter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultCounter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultCounter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultCounter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultCounter.Merge(m, src)
}
func (m *ResultCounter) XXX_Size() int {
	return m.Size()
}
func (m *ResultCounter) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultCounter.DiscardUnknown(m)
}

var xxx_messageInfo_ResultCounter proto.InternalMessageInfo

func (m *ResultCounter) GetTotal() uint32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ResultCounter) GetOk() uint32 {
	if m != nil {
		return m.Ok
	}
	return 0
}

func (m *ResultCounter) GetErr() uint32 {
	if m != nil {
		return m.Err
	}
	return 0
}

// Moving totals over sliding time windows. Models sensible time windows,
// we don't have to populate them all at once.
//
// Graphical example:
//
// time     past -> present                              an event 16 min ago
// ======================================================X================>>
//                                                       |               | 1m
//                                                       |           |---| 5m
//                                                       | |-------------| 15m
//                                          |------------X---------------| 30m
//            |------------------------------------------X---------------| 60m
type SlidingCounter struct {
	Over_1M   uint32 `protobuf:"varint,1,opt,name=over_1m,json=over1m,proto3" json:"over_1m,omitempty"`
	Over_5M   uint32 `protobuf:"varint,2,opt,name=over_5m,json=over5m,proto3" json:"over_5m,omitempty"`
	Over_15M  uint32 `protobuf:"varint,3,opt,name=over_15m,json=over15m,proto3" json:"over_15m,omitempty"`
	Over_30M  uint32 `protobuf:"varint,4,opt,name=over_30m,json=over30m,proto3" json:"over_30m,omitempty"`
	Over_1Hr  uint32 `protobuf:"varint,5,opt,name=over_1hr,json=over1hr,proto3" json:"over_1hr,omitempty"`
	Over_2Hr  uint32 `protobuf:"varint,6,opt,name=over_2hr,json=over2hr,proto3" json:"over_2hr,omitempty"`
	Over_4Hr  uint32 `protobuf:"varint,7,opt,name=over_4hr,json=over4hr,proto3" json:"over_4hr,omitempty"`
	Over_8Hr  uint32 `protobuf:"varint,8,opt,name=over_8hr,json=over8hr,proto3" json:"over_8hr,omitempty"`
	Over_12Hr uint32 `protobuf:"varint,9,opt,name=over_12hr,json=over12hr,proto3" json:"over_12hr,omitempty"`
	Over_24Hr uint32 `protobuf:"varint,10,opt,name=over_24hr,json=over24hr,proto3" json:"over_24hr,omitempty"`
}

func (m *SlidingCounter) Reset()         { *m = SlidingCounter{} }
func (m *SlidingCounter) String() string { return proto.CompactTextString(m) }
func (*SlidingCounter) ProtoMessage()    {}
func (*SlidingCounter) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{2}
}
func (m *SlidingCounter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlidingCounter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlidingCounter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlidingCounter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlidingCounter.Merge(m, src)
}
func (m *SlidingCounter) XXX_Size() int {
	return m.Size()
}
func (m *SlidingCounter) XXX_DiscardUnknown() {
	xxx_messageInfo_SlidingCounter.DiscardUnknown(m)
}

var xxx_messageInfo_SlidingCounter proto.InternalMessageInfo

func (m *SlidingCounter) GetOver_1M() uint32 {
	if m != nil {
		return m.Over_1M
	}
	return 0
}

func (m *SlidingCounter) GetOver_5M() uint32 {
	if m != nil {
		return m.Over_5M
	}
	return 0
}

func (m *SlidingCounter) GetOver_15M() uint32 {
	if m != nil {
		return m.Over_15M
	}
	return 0
}

func (m *SlidingCounter) GetOver_30M() uint32 {
	if m != nil {
		return m.Over_30M
	}
	return 0
}

func (m *SlidingCounter) GetOver_1Hr() uint32 {
	if m != nil {
		return m.Over_1Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_2Hr() uint32 {
	if m != nil {
		return m.Over_2Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_4Hr() uint32 {
	if m != nil {
		return m.Over_4Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_8Hr() uint32 {
	if m != nil {
		return m.Over_8Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_12Hr() uint32 {
	if m != nil {
		return m.Over_12Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_24Hr() uint32 {
	if m != nil {
		return m.Over_24Hr
	}
	return 0
}

// DataGauge reports stats for data traffic in a given direction.
type DataGauge struct {
	// Cumulative bytes.
	CumBytes uint64 `protobuf:"varint,1,opt,name=cum_bytes,json=cumBytes,proto3" json:"cum_bytes,omitempty"`
	// Cumulative packets.
	CumPackets uint64 `protobuf:"varint,2,opt,name=cum_packets,json=cumPackets,proto3" json:"cum_packets,omitempty"`
	// Instantaneous bandwidth measurement (bytes/second).
	InstBw uint64 `protobuf:"varint,3,opt,name=inst_bw,json=instBw,proto3" json:"inst_bw,omitempty"`
}

func (m *DataGauge) Reset()         { *m = DataGauge{} }
func (m *DataGauge) String() string { return proto.CompactTextString(m) }
func (*DataGauge) ProtoMessage()    {}
func (*DataGauge) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{3}
}
func (m *DataGauge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataGauge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataGauge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataGauge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataGauge.Merge(m, src)
}
func (m *DataGauge) XXX_Size() int {
	return m.Size()
}
func (m *DataGauge) XXX_DiscardUnknown() {
	xxx_messageInfo_DataGauge.DiscardUnknown(m)
}

var xxx_messageInfo_DataGauge proto.InternalMessageInfo

func (m *DataGauge) GetCumBytes() uint64 {
	if m != nil {
		return m.CumBytes
	}
	return 0
}

func (m *DataGauge) GetCumPackets() uint64 {
	if m != nil {
		return m.CumPackets
	}
	return 0
}

func (m *DataGauge) GetInstBw() uint64 {
	if m != nil {
		return m.InstBw
	}
	return 0
}

// Runtime encapsulates runtime info about a node.
type Runtime struct {
	// e.g. go-libp2p, js-libp2p, rust-libp2p, etc.
	Implementation string `protobuf:"bytes,1,opt,name=implementation,proto3" json:"implementation,omitempty"`
	// e.g. 1.2.3.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// e.g. Windows, Unix, macOS, Chrome, Mozilla, etc.
	Platform string `protobuf:"bytes,3,opt,name=platform,proto3" json:"platform,omitempty"`
	// our peer id - the peer id of the host system
	PeerId string `protobuf:"bytes,4,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
}

func (m *Runtime) Reset()         { *m = Runtime{} }
func (m *Runtime) String() string { return proto.CompactTextString(m) }
func (*Runtime) ProtoMessage()    {}
func (*Runtime) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{4}
}
func (m *Runtime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Runtime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Runtime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Runtime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Runtime.Merge(m, src)
}
func (m *Runtime) XXX_Size() int {
	return m.Size()
}
func (m *Runtime) XXX_DiscardUnknown() {
	xxx_messageInfo_Runtime.DiscardUnknown(m)
}

var xxx_messageInfo_Runtime proto.InternalMessageInfo

func (m *Runtime) GetImplementation() string {
	if m != nil {
		return m.Implementation
	}
	return ""
}

func (m *Runtime) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Runtime) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *Runtime) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

// EndpointPair is a pair of multiaddrs.
type EndpointPair struct {
	// the source multiaddr.
	SrcMultiaddr string `protobuf:"bytes,1,opt,name=src_multiaddr,json=srcMultiaddr,proto3" json:"src_multiaddr,omitempty"`
	// the destination multiaddr.
	DstMultiaddr string `protobuf:"bytes,2,opt,name=dst_multiaddr,json=dstMultiaddr,proto3" json:"dst_multiaddr,omitempty"`
}

func (m *EndpointPair) Reset()         { *m = EndpointPair{} }
func (m *EndpointPair) String() string { return proto.CompactTextString(m) }
func (*EndpointPair) ProtoMessage()    {}
func (*EndpointPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{5}
}
func (m *EndpointPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndpointPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndpointPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndpointPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndpointPair.Merge(m, src)
}
func (m *EndpointPair) XXX_Size() int {
	return m.Size()
}
func (m *EndpointPair) XXX_DiscardUnknown() {
	xxx_messageInfo_EndpointPair.DiscardUnknown(m)
}

var xxx_messageInfo_EndpointPair proto.InternalMessageInfo

func (m *EndpointPair) GetSrcMultiaddr() string {
	if m != nil {
		return m.SrcMultiaddr
	}
	return ""
}

func (m *EndpointPair) GetDstMultiaddr() string {
	if m != nil {
		return m.DstMultiaddr
	}
	return ""
}

// Traffic encloses data transfer statistics.
type Traffic struct {
	// snapshot of the data in metrics.
	TrafficIn *DataGauge `protobuf:"bytes,1,opt,name=traffic_in,json=trafficIn,proto3" json:"traffic_in,omitempty"`
	// snapshot of the data out metrics.
	TrafficOut *DataGauge `protobuf:"bytes,2,opt,name=traffic_out,json=trafficOut,proto3" json:"traffic_out,omitempty"`
}

func (m *Traffic) Reset()         { *m = Traffic{} }
func (m *Traffic) String() string { return proto.CompactTextString(m) }
func (*Traffic) ProtoMessage()    {}
func (*Traffic) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{6}
}
func (m *Traffic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Traffic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Traffic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Traffic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Traffic.Merge(m, src)
}
func (m *Traffic) XXX_Size() int {
	return m.Size()
}
func (m *Traffic) XXX_DiscardUnknown() {
	xxx_messageInfo_Traffic.DiscardUnknown(m)
}

var xxx_messageInfo_Traffic proto.InternalMessageInfo

func (m *Traffic) GetTrafficIn() *DataGauge {
	if m != nil {
		return m.TrafficIn
	}
	return nil
}

func (m *Traffic) GetTrafficOut() *DataGauge {
	if m != nil {
		return m.TrafficOut
	}
	return nil
}

// a list of streams, by reference or inlined.
type StreamList struct {
	// NOTE: only one of the next 2 fields can appear, but proto3
	// doesn't support combining oneof and repeated.
	//
	// streams within this connection by reference.
	StreamIds []string `protobuf:"bytes,1,rep,name=stream_ids,json=streamIds,proto3" json:"stream_ids,omitempty"`
	// streams within this connection by inlining.
	Streams []*Stream `protobuf:"bytes,2,rep,name=streams,proto3" json:"streams,omitempty"`
}

func (m *StreamList) Reset()         { *m = StreamList{} }
func (m *StreamList) String() string { return proto.CompactTextString(m) }
func (*StreamList) ProtoMessage()    {}
func (*StreamList) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{7}
}
func (m *StreamList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamList.Merge(m, src)
}
func (m *StreamList) XXX_Size() int {
	return m.Size()
}
func (m *StreamList) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamList.DiscardUnknown(m)
}

var xxx_messageInfo_StreamList proto.InternalMessageInfo

func (m *StreamList) GetStreamIds() []string {
	if m != nil {
		return m.StreamIds
	}
	return nil
}

func (m *StreamList) GetStreams() []*Stream {
	if m != nil {
		return m.Streams
	}
	return nil
}

// Connection reports metrics and state of a libp2p connection.
type Connection struct {
	// the id of this connection, not to be shown in user tooling,
	// used for (cross)referencing connections (e.g. relay).
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the peer id of the other party.
	PeerId string `protobuf:"bytes,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	// the status of this connection.
	Status Status `protobuf:"varint,3,opt,name=status,proto3,enum=introspection.pb.Status" json:"status,omitempty"`
	// a reference to the transport managing this connection.
	TransportId []byte `protobuf:"bytes,4,opt,name=transport_id,json=transportId,proto3" json:"transport_id,omitempty"`
	// the endpoints participating in this connection.
	Endpoints *EndpointPair `protobuf:"bytes,5,opt,name=endpoints,proto3" json:"endpoints,omitempty"`
	// the timeline of the connection, see Connection.Timeline.
	Timeline *Connection_Timeline `protobuf:"bytes,6,opt,name=timeline,proto3" json:"timeline,omitempty"`
	// our role in this connection.
	Role Role `protobuf:"varint,7,opt,name=role,proto3,enum=introspection.pb.Role" json:"role,omitempty"`
	// traffic statistics.
	Traffic *Traffic `protobuf:"bytes,8,opt,name=traffic,proto3" json:"traffic,omitempty"`
	// properties of this connection.
	Attribs *Connection_Attributes `protobuf:"bytes,9,opt,name=attribs,proto3" json:"attribs,omitempty"`
	// the instantaneous latency of this connection in nanoseconds.
	LatencyNs uint64 `protobuf:"varint,10,opt,name=latency_ns,json=latencyNs,proto3" json:"latency_ns,omitempty"`
	// streams within this connection.
	Streams *StreamList `protobuf:"bytes,11,opt,name=streams,proto3" json:"streams,omitempty"`
	// if this is a relayed connection, this points to the relaying connection.
	// a default value here (empty bytes) indicates this is not a relayed connection.
	//
	// Types that are valid to be assigned to RelayedOver:
	//	*Connection_ConnId
	//	*Connection_Conn
	RelayedOver isConnection_RelayedOver `protobuf_oneof:"relayed_over"`
	// user provided tags.
	UserProvidedTags []string `protobuf:"bytes,99,rep,name=user_provided_tags,json=userProvidedTags,proto3" json:"user_provided_tags,omitempty"`
}

func (m *Connection) Reset()         { *m = Connection{} }
func (m *Connection) String() string { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()    {}
func (*Connection) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{8}
}
func (m *Connection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection.Merge(m, src)
}
func (m *Connection) XXX_Size() int {
	return m.Size()
}
func (m *Connection) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection.DiscardUnknown(m)
}

var xxx_messageInfo_Connection proto.InternalMessageInfo

type isConnection_RelayedOver interface {
	isConnection_RelayedOver()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Connection_ConnId struct {
	ConnId string `protobuf:"bytes,16,opt,name=conn_id,json=connId,proto3,oneof"`
}
type Connection_Conn struct {
	Conn *Connection `protobuf:"bytes,17,opt,name=conn,proto3,oneof"`
}

func (*Connection_ConnId) isConnection_RelayedOver() {}
func (*Connection_Conn) isConnection_RelayedOver()   {}

func (m *Connection) GetRelayedOver() isConnection_RelayedOver {
	if m != nil {
		return m.RelayedOver
	}
	return nil
}

func (m *Connection) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Connection) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *Connection) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_ACTIVE
}

func (m *Connection) GetTransportId() []byte {
	if m != nil {
		return m.TransportId
	}
	return nil
}

func (m *Connection) GetEndpoints() *EndpointPair {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *Connection) GetTimeline() *Connection_Timeline {
	if m != nil {
		return m.Timeline
	}
	return nil
}

func (m *Connection) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_INITIATOR
}

func (m *Connection) GetTraffic() *Traffic {
	if m != nil {
		return m.Traffic
	}
	return nil
}

func (m *Connection) GetAttribs() *Connection_Attributes {
	if m != nil {
		return m.Attribs
	}
	return nil
}

func (m *Connection) GetLatencyNs() uint64 {
	if m != nil {
		return m.LatencyNs
	}
	return 0
}

func (m *Connection) GetStreams() *StreamList {
	if m != nil {
		return m.Streams
	}
	return nil
}

func (m *Connection) GetConnId() string {
	if x, ok := m.GetRelayedOver().(*Connection_ConnId); ok {
		return x.ConnId
	}
	return ""
}

func (m *Connection) GetConn() *Connection {
	if x, ok := m.GetRelayedOver().(*Connection_Conn); ok {
		return x.Conn
	}
	return nil
}

func (m *Connection) GetUserProvidedTags() []string {
	if m != nil {
		return m.UserProvidedTags
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Connection) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Connection_OneofMarshaler, _Connection_OneofUnmarshaler, _Connection_OneofSizer, []interface{}{
		(*Connection_ConnId)(nil),
		(*Connection_Conn)(nil),
	}
}

func _Connection_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Connection)
	// relayed_over
	switch x := m.RelayedOver.(type) {
	case *Connection_ConnId:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ConnId)
	case *Connection_Conn:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Conn); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Connection.RelayedOver has unexpected type %T", x)
	}
	return nil
}

func _Connection_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Connection)
	switch tag {
	case 16: // relayed_over.conn_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.RelayedOver = &Connection_ConnId{x}
		return true, err
	case 17: // relayed_over.conn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Connection)
		err := b.DecodeMessage(msg)
		m.RelayedOver = &Connection_Conn{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Connection_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Connection)
	// relayed_over
	switch x := m.RelayedOver.(type) {
	case *Connection_ConnId:
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(len(x.ConnId)))
		n += len(x.ConnId)
	case *Connection_Conn:
		s := proto.Size(x.Conn)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Timeline contains the timestamps of the well-known milestones of a connection.
type Connection_Timeline struct {
	// the instant when a connection was opened on the wire.
	OpenTs *time.Time `protobuf:"bytes,1,opt,name=open_ts,json=openTs,proto3,stdtime" json:"open_ts,omitempty"`
	// the instant when the upgrade process (handshake, security, multiplexing) finished.
	UpgradedTs *time.Time `protobuf:"bytes,2,opt,name=upgraded_ts,json=upgradedTs,proto3,stdtime" json:"upgraded_ts,omitempty"`
	// the instant when this connection was terminated.
	CloseTs *time.Time `protobuf:"bytes,3,opt,name=close_ts,json=closeTs,proto3,stdtime" json:"close_ts,omitempty"`
}

func (m *Connection_Timeline) Reset()         { *m = Connection_Timeline{} }
func (m *Connection_Timeline) String() string { return proto.CompactTextString(m) }
func (*Connection_Timeline) ProtoMessage()    {}
func (*Connection_Timeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{8, 0}
}
func (m *Connection_Timeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection_Timeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection_Timeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection_Timeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection_Timeline.Merge(m, src)
}
func (m *Connection_Timeline) XXX_Size() int {
	return m.Size()
}
func (m *Connection_Timeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection_Timeline.DiscardUnknown(m)
}

var xxx_messageInfo_Connection_Timeline proto.InternalMessageInfo

func (m *Connection_Timeline) GetOpenTs() *time.Time {
	if m != nil {
		return m.OpenTs
	}
	return nil
}

func (m *Connection_Timeline) GetUpgradedTs() *time.Time {
	if m != nil {
		return m.UpgradedTs
	}
	return nil
}

func (m *Connection_Timeline) GetCloseTs() *time.Time {
	if m != nil {
		return m.CloseTs
	}
	return nil
}

// Attributes encapsulates the attributes of this connection.
type Connection_Attributes struct {
	// the multiplexer being used.
	Multiplexer string `protobuf:"bytes,1,opt,name=multiplexer,proto3" json:"multiplexer,omitempty"`
	// the encryption method being used.
	Encryption string `protobuf:"bytes,2,opt,name=encryption,proto3" json:"encryption,omitempty"`
}

func (m *Connection_Attributes) Reset()         { *m = Connection_Attributes{} }
func (m *Connection_Attributes) String() string { return proto.CompactTextString(m) }
func (*Connection_Attributes) ProtoMessage()    {}
func (*Connection_Attributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{8, 1}
}
func (m *Connection_Attributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection_Attributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection_Attributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection_Attributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection_Attributes.Merge(m, src)
}
func (m *Connection_Attributes) XXX_Size() int {
	return m.Size()
}
func (m *Connection_Attributes) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection_Attributes.DiscardUnknown(m)
}

var xxx_messageInfo_Connection_Attributes proto.InternalMessageInfo

func (m *Connection_Attributes) GetMultiplexer() string {
	if m != nil {
		return m.Multiplexer
	}
	return ""
}

func (m *Connection_Attributes) GetEncryption() string {
	if m != nil {
		return m.Encryption
	}
	return ""
}

// Stream reports metrics and state of a libp2p stream.
type Stream struct {
	// the id of this stream, not to be shown in user tooling,
	// used for (cross)referencing streams.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the protocol pinned to this stream.
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// our role in this stream.
	Role Role `protobuf:"varint,3,opt,name=role,proto3,enum=introspection.pb.Role" json:"role,omitempty"`
	// traffic statistics.
	Traffic *Traffic `protobuf:"bytes,4,opt,name=traffic,proto3" json:"traffic,omitempty"`
	// the connection this stream is hosted under.
	Conn *Stream_ConnectionRef `protobuf:"bytes,5,opt,name=conn,proto3" json:"conn,omitempty"`
	// the timeline of the stream, see Stream.Timeline.
	Timeline *Stream_Timeline `protobuf:"bytes,6,opt,name=timeline,proto3" json:"timeline,omitempty"`
	// the status of this stream.
	Status Status `protobuf:"varint,7,opt,name=status,proto3,enum=introspection.pb.Status" json:"status,omitempty"`
	// the instantaneous latency of this stream in nanoseconds.
	// TODO: this is hard to calculate.
	LatencyNs uint64 `protobuf:"varint,16,opt,name=latency_ns,json=latencyNs,proto3" json:"latency_ns,omitempty"`
	// user provided tags.
	UserProvidedTags []string `protobuf:"bytes,99,rep,name=user_provided_tags,json=userProvidedTags,proto3" json:"user_provided_tags,omitempty"`
}

func (m *Stream) Reset()         { *m = Stream{} }
func (m *Stream) String() string { return proto.CompactTextString(m) }
func (*Stream) ProtoMessage()    {}
func (*Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{9}
}
func (m *Stream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream.Merge(m, src)
}
func (m *Stream) XXX_Size() int {
	return m.Size()
}
func (m *Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_Stream proto.InternalMessageInfo

func (m *Stream) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Stream) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Stream) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_INITIATOR
}

func (m *Stream) GetTraffic() *Traffic {
	if m != nil {
		return m.Traffic
	}
	return nil
}

func (m *Stream) GetConn() *Stream_ConnectionRef {
	if m != nil {
		return m.Conn
	}
	return nil
}

func (m *Stream) GetTimeline() *Stream_Timeline {
	if m != nil {
		return m.Timeline
	}
	return nil
}

func (m *Stream) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_ACTIVE
}

func (m *Stream) GetLatencyNs() uint64 {
	if m != nil {
		return m.LatencyNs
	}
	return 0
}

func (m *Stream) GetUserProvidedTags() []string {
	if m != nil {
		return m.UserProvidedTags
	}
	return nil
}

type Stream_ConnectionRef struct {
	// Types that are valid to be assigned to Connection:
	//	*Stream_ConnectionRef_Conn
	//	*Stream_ConnectionRef_ConnId
	Connection isStream_ConnectionRef_Connection `protobuf_oneof:"connection"`
}

func (m *Stream_ConnectionRef) Reset()         { *m = Stream_ConnectionRef{} }
func (m *Stream_ConnectionRef) String() string { return proto.CompactTextString(m) }
func (*Stream_ConnectionRef) ProtoMessage()    {}
func (*Stream_ConnectionRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{9, 0}
}
func (m *Stream_ConnectionRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream_ConnectionRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream_ConnectionRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream_ConnectionRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream_ConnectionRef.Merge(m, src)
}
func (m *Stream_ConnectionRef) XXX_Size() int {
	return m.Size()
}
func (m *Stream_ConnectionRef) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream_ConnectionRef.DiscardUnknown(m)
}

var xxx_messageInfo_Stream_ConnectionRef proto.InternalMessageInfo

type isStream_ConnectionRef_Connection interface {
	isStream_ConnectionRef_Connection()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Stream_ConnectionRef_Conn struct {
	Conn *Connection `protobuf:"bytes,1,opt,name=conn,proto3,oneof"`
}
type Stream_ConnectionRef_ConnId struct {
	ConnId string `protobuf:"bytes,2,opt,name=conn_id,json=connId,proto3,oneof"`
}

func (*Stream_ConnectionRef_Conn) isStream_ConnectionRef_Connection()   {}
func (*Stream_ConnectionRef_ConnId) isStream_ConnectionRef_Connection() {}

func (m *Stream_ConnectionRef) GetConnection() isStream_ConnectionRef_Connection {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *Stream_ConnectionRef) GetConn() *Connection {
	if x, ok := m.GetConnection().(*Stream_ConnectionRef_Conn); ok {
		return x.Conn
	}
	return nil
}

func (m *Stream_ConnectionRef) GetConnId() string {
	if x, ok := m.GetConnection().(*Stream_ConnectionRef_ConnId); ok {
		return x.ConnId
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Stream_ConnectionRef) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Stream_ConnectionRef_OneofMarshaler, _Stream_ConnectionRef_OneofUnmarshaler, _Stream_ConnectionRef_OneofSizer, []interface{}{
		(*Stream_ConnectionRef_Conn)(nil),
		(*Stream_ConnectionRef_ConnId)(nil),
	}
}

func _Stream_ConnectionRef_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Stream_ConnectionRef)
	// connection
	switch x := m.Connection.(type) {
	case *Stream_ConnectionRef_Conn:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Conn); err != nil {
			return err
		}
	case *Stream_ConnectionRef_ConnId:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ConnId)
	case nil:
	default:
		return fmt.Errorf("Stream_ConnectionRef.Connection has unexpected type %T", x)
	}
	return nil
}

func _Stream_ConnectionRef_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Stream_ConnectionRef)
	switch tag {
	case 1: // connection.conn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Connection)
		err := b.DecodeMessage(msg)
		m.Connection = &Stream_ConnectionRef_Conn{msg}
		return true, err
	case 2: // connection.conn_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Connection = &Stream_ConnectionRef_ConnId{x}
		return true, err
	default:
		return false, nil
	}
}

func _Stream_ConnectionRef_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Stream_ConnectionRef)
	// connection
	switch x := m.Connection.(type) {
	case *Stream_ConnectionRef_Conn:
		s := proto.Size(x.Conn)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stream_ConnectionRef_ConnId:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.ConnId)))
		n += len(x.ConnId)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Timeline contains the timestamps of the well-known milestones of a stream.
type Stream_Timeline struct {
	// the instant when the stream was opened.
	OpenTs *time.Time `protobuf:"bytes,1,opt,name=open_ts,json=openTs,proto3,stdtime" json:"open_ts,omitempty"`
	// the instant when the stream was terminated.
	CloseTs *time.Time `protobuf:"bytes,2,opt,name=close_ts,json=closeTs,proto3,stdtime" json:"close_ts,omitempty"`
}

func (m *Stream_Timeline) Reset()         { *m = Stream_Timeline{} }
func (m *Stream_Timeline) String() string { return proto.CompactTextString(m) }
func (*Stream_Timeline) ProtoMessage()    {}
func (*Stream_Timeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{9, 1}
}
func (m *Stream_Timeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream_Timeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream_Timeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream_Timeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream_Timeline.Merge(m, src)
}
func (m *Stream_Timeline) XXX_Size() int {
	return m.Size()
}
func (m *Stream_Timeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream_Timeline.DiscardUnknown(m)
}

var xxx_messageInfo_Stream_Timeline proto.InternalMessageInfo

func (m *Stream_Timeline) GetOpenTs() *time.Time {
	if m != nil {
		return m.OpenTs
	}
	return nil
}

func (m *Stream_Timeline) GetCloseTs() *time.Time {
	if m != nil {
		return m.CloseTs
	}
	return nil
}

// DHT metrics and state.
type DHT struct {
	// DHT protocol name
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// protocol enabled.
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// timestap of start up.
	StartTs *time.Time `protobuf:"bytes,3,opt,name=start_ts,json=startTs,proto3,stdtime" json:"start_ts,omitempty"`
	// params of the dht.
	Params *DHT_Params `protobuf:"bytes,4,opt,name=params,proto3" json:"params,omitempty"`
	// queries data
	Query []*DHT_Query `protobuf:"bytes,5,rep,name=query,proto3" json:"query,omitempty"`
}

func (m *DHT) Reset()         { *m = DHT{} }
func (m *DHT) String() string { return proto.CompactTextString(m) }
func (*DHT) ProtoMessage()    {}
func (*DHT) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{10}
}
func (m *DHT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHT.Merge(m, src)
}
func (m *DHT) XXX_Size() int {
	return m.Size()
}
func (m *DHT) XXX_DiscardUnknown() {
	xxx_messageInfo_DHT.DiscardUnknown(m)
}

var xxx_messageInfo_DHT proto.InternalMessageInfo

func (m *DHT) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *DHT) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *DHT) GetStartTs() *time.Time {
	if m != nil {
		return m.StartTs
	}
	return nil
}

func (m *DHT) GetParams() *DHT_Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *DHT) GetQuery() []*DHT_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

type DHT_Params struct {
	// maximum number of requests to perform.
	K uint64 `protobuf:"varint,1,opt,name=k,proto3" json:"k,omitempty"`
	// concurrency of asynchronous requests.
	Alpha uint64 `protobuf:"varint,2,opt,name=alpha,proto3" json:"alpha,omitempty"`
	// number of disjoint paths to use.
	DisjointPaths uint64 `protobuf:"varint,3,opt,name=disjoint_paths,json=disjointPaths,proto3" json:"disjoint_paths,omitempty"`
}

func (m *DHT_Params) Reset()         { *m = DHT_Params{} }
func (m *DHT_Params) String() string { return proto.CompactTextString(m) }
func (*DHT_Params) ProtoMessage()    {}
func (*DHT_Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{10, 0}
}
func (m *DHT_Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHT_Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHT_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHT_Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHT_Params.Merge(m, src)
}
func (m *DHT_Params) XXX_Size() int {
	return m.Size()
}
func (m *DHT_Params) XXX_DiscardUnknown() {
	xxx_messageInfo_DHT_Params.DiscardUnknown(m)
}

var xxx_messageInfo_DHT_Params proto.InternalMessageInfo

func (m *DHT_Params) GetK() uint64 {
	if m != nil {
		return m.K
	}
	return 0
}

func (m *DHT_Params) GetAlpha() uint64 {
	if m != nil {
		return m.Alpha
	}
	return 0
}

func (m *DHT_Params) GetDisjointPaths() uint64 {
	if m != nil {
		return m.DisjointPaths
	}
	return 0
}

type DHT_Query struct {
	// id of the query; used for internal referencing (<== TODO: confirm this)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// id of the peer being sought by this query
	TargetPeerId string `protobuf:"bytes,2,opt,name=target_peer_id,json=targetPeerId,proto3" json:"target_peer_id,omitempty"`
	// total time of the query in miliseconds
	TotalTimeMs uint64 `protobuf:"varint,3,opt,name=total_time_ms,json=totalTimeMs,proto3" json:"total_time_ms,omitempty"`
	// number of iterative lookups before reaching result
	TotalSteps uint64 `protobuf:"varint,4,opt,name=total_steps,json=totalSteps,proto3" json:"total_steps,omitempty"`
	// peers queried.
	PeerIds []string `protobuf:"bytes,5,rep,name=peer_ids,json=peerIds,proto3" json:"peer_ids,omitempty"`
	// trigger of the query
	Trigger DHT_Query_Trigger `protobuf:"varint,6,opt,name=trigger,proto3,enum=introspection.pb.DHT_Query_Trigger" json:"trigger,omitempty"`
	// type of the query.
	Type DHT_Query_Type `protobuf:"varint,7,opt,name=type,proto3,enum=introspection.pb.DHT_Query_Type" json:"type,omitempty"`
	// status indicating the result of the query
	Result DHT_Query_Result `protobuf:"varint,8,opt,name=result,proto3,enum=introspection.pb.DHT_Query_Result" json:"result,omitempty"`
	// time query was dispatched
	SentTs *time.Time `protobuf:"bytes,9,opt,name=sent_ts,json=sentTs,proto3,stdtime" json:"sent_ts,omitempty"`
}

func (m *DHT_Query) Reset()         { *m = DHT_Query{} }
func (m *DHT_Query) String() string { return proto.CompactTextString(m) }
func (*DHT_Query) ProtoMessage()    {}
func (*DHT_Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{10, 1}
}
func (m *DHT_Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHT_Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHT_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHT_Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHT_Query.Merge(m, src)
}
func (m *DHT_Query) XXX_Size() int {
	return m.Size()
}
func (m *DHT_Query) XXX_DiscardUnknown() {
	xxx_messageInfo_DHT_Query.DiscardUnknown(m)
}

var xxx_messageInfo_DHT_Query proto.InternalMessageInfo

func (m *DHT_Query) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DHT_Query) GetTargetPeerId() string {
	if m != nil {
		return m.TargetPeerId
	}
	return ""
}

func (m *DHT_Query) GetTotalTimeMs() uint64 {
	if m != nil {
		return m.TotalTimeMs
	}
	return 0
}

func (m *DHT_Query) GetTotalSteps() uint64 {
	if m != nil {
		return m.TotalSteps
	}
	return 0
}

func (m *DHT_Query) GetPeerIds() []string {
	if m != nil {
		return m.PeerIds
	}
	return nil
}

func (m *DHT_Query) GetTrigger() DHT_Query_Trigger {
	if m != nil {
		return m.Trigger
	}
	return DHT_Query_API
}

func (m *DHT_Query) GetType() DHT_Query_Type {
	if m != nil {
		return m.Type
	}
	return DHT_Query_CONTENT
}

func (m *DHT_Query) GetResult() DHT_Query_Result {
	if m != nil {
		return m.Result
	}
	return DHT_Query_SUCCESS
}

func (m *DHT_Query) GetSentTs() *time.Time {
	if m != nil {
		return m.SentTs
	}
	return nil
}

// Subsystems encapsulates all instrumented subsystems for a libp2p host.
type Subsystems struct {
	// connections data, source agnostic but currently only supports the Swarm subsystem
	Connections []*Connection `protobuf:"bytes,1,rep,name=connections,proto3" json:"connections,omitempty"`
	// the DHT subsystem.
	Dht *DHT `protobuf:"bytes,2,opt,name=dht,proto3" json:"dht,omitempty"`
}

func (m *Subsystems) Reset()         { *m = Subsystems{} }
func (m *Subsystems) String() string { return proto.CompactTextString(m) }
func (*Subsystems) ProtoMessage()    {}
func (*Subsystems) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{11}
}
func (m *Subsystems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subsystems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subsystems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subsystems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subsystems.Merge(m, src)
}
func (m *Subsystems) XXX_Size() int {
	return m.Size()
}
func (m *Subsystems) XXX_DiscardUnknown() {
	xxx_messageInfo_Subsystems.DiscardUnknown(m)
}

var xxx_messageInfo_Subsystems proto.InternalMessageInfo

func (m *Subsystems) GetConnections() []*Connection {
	if m != nil {
		return m.Connections
	}
	return nil
}

func (m *Subsystems) GetDht() *DHT {
	if m != nil {
		return m.Dht
	}
	return nil
}

// Connections and streams output for a time interval is one of these.
type State struct {
	// Version of this protobuf
	Version *Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// system information
	Runtime *Runtime `protobuf:"bytes,2,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// list of connections
	Subsystems *Subsystems `protobuf:"bytes,3,opt,name=subsystems,proto3" json:"subsystems,omitempty"`
	// overall traffic for this peer
	Traffic *Traffic `protobuf:"bytes,4,opt,name=traffic,proto3" json:"traffic,omitempty"`
	// moment this data snapshot and instantaneous values were taken
	InstantTs *types.Timestamp `protobuf:"bytes,5,opt,name=instant_ts,json=instantTs,proto3" json:"instant_ts,omitempty"`
	// start of included data collection (cumulative values counted from here)
	StartTs *types.Timestamp `protobuf:"bytes,6,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	// length of time up to instant_ts covered by this data snapshot
	SnapshotDurationMs uint32 `protobuf:"varint,7,opt,name=snapshot_duration_ms,json=snapshotDurationMs,proto3" json:"snapshot_duration_ms,omitempty"`
}

func (m *State) Reset()         { *m = State{} }
func (m *State) String() string { return proto.CompactTextString(m) }
func (*State) ProtoMessage()    {}
func (*State) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{12}
}
func (m *State) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *State) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_State.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *State) XXX_Merge(src proto.Message) {
	xxx_messageInfo_State.Merge(m, src)
}
func (m *State) XXX_Size() int {
	return m.Size()
}
func (m *State) XXX_DiscardUnknown() {
	xxx_messageInfo_State.DiscardUnknown(m)
}

var xxx_messageInfo_State proto.InternalMessageInfo

func (m *State) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *State) GetRuntime() *Runtime {
	if m != nil {
		return m.Runtime
	}
	return nil
}

func (m *State) GetSubsystems() *Subsystems {
	if m != nil {
		return m.Subsystems
	}
	return nil
}

func (m *State) GetTraffic() *Traffic {
	if m != nil {
		return m.Traffic
	}
	return nil
}

func (m *State) GetInstantTs() *types.Timestamp {
	if m != nil {
		return m.InstantTs
	}
	return nil
}

func (m *State) GetStartTs() *types.Timestamp {
	if m != nil {
		return m.StartTs
	}
	return nil
}

func (m *State) GetSnapshotDurationMs() uint32 {
	if m != nil {
		return m.SnapshotDurationMs
	}
	return 0
}

func init() {
	proto.RegisterEnum("introspection.pb.Status", Status_name, Status_value)
	proto.RegisterEnum("introspection.pb.Role", Role_name, Role_value)
	proto.RegisterEnum("introspection.pb.DHT_Query_Trigger", DHT_Query_Trigger_name, DHT_Query_Trigger_value)
	proto.RegisterEnum("introspection.pb.DHT_Query_Type", DHT_Query_Type_name, DHT_Query_Type_value)
	proto.RegisterEnum("introspection.pb.DHT_Query_Result", DHT_Query_Result_name, DHT_Query_Result_value)
	proto.RegisterType((*Version)(nil), "introspection.pb.Version")
	proto.RegisterType((*ResultCounter)(nil), "introspection.pb.ResultCounter")
	proto.RegisterType((*SlidingCounter)(nil), "introspection.pb.SlidingCounter")
	proto.RegisterType((*DataGauge)(nil), "introspection.pb.DataGauge")
	proto.RegisterType((*Runtime)(nil), "introspection.pb.Runtime")
	proto.RegisterType((*EndpointPair)(nil), "introspection.pb.EndpointPair")
	proto.RegisterType((*Traffic)(nil), "introspection.pb.Traffic")
	proto.RegisterType((*StreamList)(nil), "introspection.pb.StreamList")
	proto.RegisterType((*Connection)(nil), "introspection.pb.Connection")
	proto.RegisterType((*Connection_Timeline)(nil), "introspection.pb.Connection.Timeline")
	proto.RegisterType((*Connection_Attributes)(nil), "introspection.pb.Connection.Attributes")
	proto.RegisterType((*Stream)(nil), "introspection.pb.Stream")
	proto.RegisterType((*Stream_ConnectionRef)(nil), "introspection.pb.Stream.ConnectionRef")
	proto.RegisterType((*Stream_Timeline)(nil), "introspection.pb.Stream.Timeline")
	proto.RegisterType((*DHT)(nil), "introspection.pb.DHT")
	proto.RegisterType((*DHT_Params)(nil), "introspection.pb.DHT.Params")
	proto.RegisterType((*DHT_Query)(nil), "introspection.pb.DHT.Query")
	proto.RegisterType((*Subsystems)(nil), "introspection.pb.Subsystems")
	proto.RegisterType((*State)(nil), "introspection.pb.State")
}

func init() { proto.RegisterFile("introspection.proto", fileDescriptor_53a8bedf9a75e10a) }

var fileDescriptor_53a8bedf9a75e10a = []byte{
	// 1681 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4b, 0x93, 0x1b, 0x49,
	0x11, 0xd6, 0xa3, 0xa5, 0x56, 0xa7, 0x34, 0x0a, 0x51, 0x2c, 0x8b, 0x2c, 0xc3, 0xd8, 0xee, 0x7d,
	0x39, 0x1c, 0x8b, 0xd6, 0xd6, 0xd8, 0xc4, 0xae, 0xf1, 0x12, 0x31, 0x0f, 0x85, 0x2d, 0xc2, 0x96,
	0x44, 0xa9, 0x3d, 0x01, 0xa7, 0x8e, 0x96, 0xba, 0x46, 0x6a, 0xa6, 0x5f, 0x54, 0x55, 0x7b, 0x99,
	0x1b, 0xb1, 0x5c, 0x38, 0xee, 0x89, 0x23, 0xff, 0x81, 0x1f, 0x41, 0x04, 0x37, 0xf6, 0xc8, 0x0d,
	0xc2, 0xfe, 0x23, 0x44, 0x3d, 0x5a, 0xea, 0x79, 0x79, 0x66, 0x08, 0x6e, 0x9d, 0x99, 0x5f, 0x56,
	0x56, 0x57, 0x7e, 0x99, 0x59, 0x05, 0x3f, 0x0c, 0x62, 0x4e, 0x13, 0x96, 0x92, 0x05, 0x0f, 0x92,
	0xb8, 0x9f, 0xd2, 0x84, 0x27, 0xa8, 0x73, 0x46, 0x39, 0xef, 0xfd, 0x6c, 0x19, 0xf0, 0x55, 0x36,
	0xef, 0x2f, 0x92, 0xe8, 0x8b, 0x65, 0xb2, 0x4c, 0xbe, 0x90, 0xc0, 0x79, 0x76, 0x24, 0x25, 0x29,
	0xc8, 0x2f, 0xb5, 0x40, 0xef, 0xce, 0x32, 0x49, 0x96, 0x21, 0xd9, 0xa0, 0x78, 0x10, 0x11, 0xc6,
	0xbd, 0x28, 0x55, 0x00, 0xfb, 0x1e, 0x98, 0x87, 0x84, 0xb2, 0x20, 0x89, 0xd1, 0x87, 0x50, 0x8f,
	0xb3, 0x68, 0x4e, 0x68, 0xb7, 0x7c, 0xb7, 0x7c, 0x7f, 0x0b, 0x6b, 0xc9, 0x7e, 0x0e, 0x5b, 0x98,
	0xb0, 0x2c, 0xe4, 0xfb, 0x49, 0x16, 0x73, 0x42, 0xd1, 0x07, 0x50, 0xe3, 0x09, 0xf7, 0x42, 0x8d,
	0x53, 0x02, 0x6a, 0x43, 0x25, 0x39, 0xee, 0x56, 0xa4, 0xaa, 0x92, 0x1c, 0xa3, 0x0e, 0x54, 0x09,
	0xa5, 0xdd, 0xaa, 0x54, 0x88, 0x4f, 0xfb, 0xaf, 0x15, 0x68, 0xcf, 0xc2, 0xc0, 0x0f, 0xe2, 0x65,
	0xbe, 0xd4, 0x8f, 0xc1, 0x4c, 0xde, 0x10, 0xea, 0x3e, 0x8a, 0xf2, 0xa0, 0x42, 0x7c, 0x14, 0xad,
	0x0d, 0x4f, 0x22, 0xbd, 0xa4, 0x34, 0x3c, 0x89, 0xd0, 0x2d, 0x68, 0x28, 0x8f, 0x27, 0x91, 0x5e,
	0x5b, 0x02, 0x1f, 0x15, 0x4c, 0x3b, 0x0f, 0xa3, 0xae, 0xb1, 0x31, 0xed, 0x3c, 0x2c, 0x78, 0xad,
	0x68, 0xb7, 0x56, 0xf0, 0x5a, 0xd1, 0xb5, 0x69, 0xb0, 0xa2, 0xdd, 0xfa, 0xc6, 0x34, 0x28, 0x98,
	0x1e, 0xaf, 0x68, 0xd7, 0xdc, 0x98, 0x1e, 0x17, 0x4c, 0x5f, 0xae, 0x68, 0xb7, 0xb1, 0x31, 0x7d,
	0xb9, 0xa2, 0xe8, 0x36, 0x58, 0x2a, 0x96, 0x58, 0xd1, 0x92, 0x36, 0x89, 0x15, 0xf2, 0xda, 0x38,
	0x10, 0x6b, 0xc2, 0xc6, 0x28, 0x64, 0x7b, 0x0e, 0xd6, 0x81, 0xc7, 0xbd, 0xe7, 0x5e, 0xb6, 0x24,
	0x02, 0xb9, 0xc8, 0x22, 0x77, 0x7e, 0xc2, 0x09, 0x93, 0x87, 0x63, 0xe0, 0xc6, 0x22, 0x8b, 0xf6,
	0x84, 0x8c, 0xee, 0x40, 0x53, 0x18, 0x53, 0x6f, 0x71, 0x4c, 0x38, 0x93, 0x47, 0x64, 0x60, 0x58,
	0x64, 0xd1, 0x54, 0x69, 0xc4, 0xf9, 0x05, 0x31, 0xe3, 0xee, 0xfc, 0x1b, 0x79, 0x4a, 0x06, 0xae,
	0x0b, 0x71, 0xef, 0x1b, 0xfb, 0x8f, 0x65, 0x30, 0x71, 0x16, 0x0b, 0x1e, 0xa0, 0x4f, 0xa1, 0x1d,
	0x44, 0x69, 0x48, 0x22, 0x12, 0x73, 0x4f, 0x30, 0x4c, 0xc6, 0xb1, 0xf0, 0x19, 0x2d, 0xea, 0x82,
	0xf9, 0x46, 0x91, 0x44, 0x46, 0xb2, 0x70, 0x2e, 0xa2, 0x1e, 0x34, 0xd2, 0xd0, 0xe3, 0x47, 0x09,
	0x55, 0xd9, 0xb0, 0xf0, 0x5a, 0x16, 0x5b, 0x48, 0x09, 0xa1, 0x6e, 0xe0, 0xcb, 0x6c, 0x58, 0xb8,
	0x2e, 0xc4, 0x91, 0x6f, 0xff, 0x06, 0x5a, 0xc3, 0xd8, 0x4f, 0x93, 0x20, 0xe6, 0x53, 0x2f, 0xa0,
	0xe8, 0x23, 0xd8, 0x62, 0x74, 0xe1, 0x46, 0x59, 0xc8, 0x03, 0xcf, 0xf7, 0xa9, 0xde, 0x45, 0x8b,
	0xd1, 0xc5, 0xab, 0x5c, 0x27, 0x40, 0x3e, 0xe3, 0x05, 0x90, 0xda, 0x49, 0xcb, 0x67, 0x7c, 0x0d,
	0xb2, 0xff, 0x54, 0x06, 0xd3, 0xa1, 0xde, 0xd1, 0x51, 0xb0, 0x40, 0x4f, 0x01, 0xb8, 0xfa, 0x74,
	0x03, 0xf5, 0x63, 0xcd, 0xc1, 0xed, 0xfe, 0xd9, 0x82, 0xea, 0xaf, 0x0f, 0x1c, 0x5b, 0x1a, 0x3e,
	0x8a, 0xd1, 0x33, 0x68, 0xe6, 0xbe, 0x49, 0xc6, 0x65, 0xa8, 0x2b, 0x9c, 0xf3, 0x58, 0x93, 0x8c,
	0xdb, 0x2e, 0xc0, 0x8c, 0x53, 0xe2, 0x45, 0x2f, 0x03, 0xc6, 0xd1, 0x4f, 0x01, 0x98, 0x94, 0xdc,
	0xc0, 0x17, 0x89, 0xac, 0xde, 0xb7, 0xb0, 0xa5, 0x34, 0x23, 0x9f, 0xa1, 0x01, 0x98, 0x4a, 0x10,
	0x59, 0xac, 0xde, 0x6f, 0x0e, 0xba, 0xe7, 0xc3, 0xa8, 0xd5, 0x70, 0x0e, 0xb4, 0xff, 0x66, 0x02,
	0xec, 0x27, 0x71, 0xac, 0x10, 0xa2, 0xf2, 0x02, 0x5f, 0x1f, 0x5a, 0x25, 0xf0, 0x8b, 0x07, 0x5f,
	0x29, 0x1e, 0x3c, 0x7a, 0x08, 0x75, 0xc6, 0x3d, 0x9e, 0x31, 0x99, 0xab, 0xf6, 0xc5, 0xa1, 0x84,
	0x1d, 0x6b, 0x1c, 0xba, 0x07, 0x2d, 0x4e, 0xbd, 0x98, 0xa5, 0x09, 0xe5, 0x79, 0x22, 0x5b, 0xb8,
	0xb9, 0xd6, 0x8d, 0x7c, 0xf4, 0x0c, 0x2c, 0xa2, 0xb3, 0xc9, 0x64, 0x6d, 0x35, 0x07, 0xdb, 0xe7,
	0xd7, 0x2d, 0x26, 0x1c, 0x6f, 0x1c, 0xd0, 0x2e, 0x34, 0x04, 0x15, 0xc3, 0x20, 0x26, 0xb2, 0xfa,
	0x9a, 0x83, 0x4f, 0xce, 0x3b, 0x6f, 0xfe, 0xb5, 0xef, 0x68, 0x30, 0x5e, 0xbb, 0xa1, 0x07, 0x60,
	0xd0, 0x24, 0x24, 0xb2, 0x42, 0xdb, 0x83, 0x0f, 0xcf, 0xbb, 0xe3, 0x24, 0x24, 0x58, 0x62, 0xd0,
	0x0e, 0x98, 0x3a, 0x51, 0xb2, 0x6a, 0x9b, 0x83, 0x5b, 0xe7, 0xe1, 0x9a, 0x40, 0x38, 0x47, 0xa2,
	0x5d, 0x30, 0x3d, 0xce, 0x69, 0x30, 0x67, 0xb2, 0x9c, 0x9b, 0x83, 0xcf, 0xde, 0xbb, 0xc5, 0x5d,
	0x89, 0xcd, 0x38, 0x61, 0x38, 0xf7, 0x13, 0x24, 0x08, 0x3d, 0x4e, 0xe2, 0xc5, 0x89, 0x1b, 0x33,
	0x59, 0xf7, 0x06, 0xb6, 0xb4, 0x66, 0xcc, 0xd0, 0xcf, 0x37, 0x24, 0x68, 0xca, 0x08, 0x3f, 0xb9,
	0x8c, 0x04, 0x82, 0x52, 0x6b, 0x22, 0xa0, 0x5b, 0x60, 0x2e, 0x92, 0x38, 0x16, 0x99, 0xe9, 0x88,
	0x4c, 0xbf, 0x28, 0xe1, 0xba, 0x50, 0x8c, 0x7c, 0x34, 0x00, 0x43, 0x7c, 0x75, 0x7f, 0x70, 0xd9,
	0x7a, 0x9b, 0x1d, 0xbf, 0x28, 0x61, 0x89, 0x45, 0x9f, 0x03, 0xca, 0x18, 0xa1, 0x6e, 0x4a, 0x93,
	0x37, 0x81, 0x4f, 0x7c, 0x97, 0x7b, 0x4b, 0xd6, 0x5d, 0x48, 0xca, 0x76, 0x84, 0x65, 0xaa, 0x0d,
	0x8e, 0xb7, 0x64, 0xbd, 0xbf, 0x97, 0xa1, 0x91, 0xa7, 0x03, 0x7d, 0x05, 0x66, 0x92, 0x92, 0xd8,
	0xe5, 0x4c, 0x97, 0x5a, 0xaf, 0xaf, 0x46, 0x4f, 0x3f, 0x1f, 0x3d, 0x32, 0x75, 0x72, 0xf4, 0xec,
	0x19, 0xdf, 0xfd, 0xfb, 0x4e, 0x19, 0xd7, 0x85, 0x83, 0x23, 0x28, 0xd0, 0xcc, 0xd2, 0x25, 0xf5,
	0x64, 0x40, 0xa6, 0x8b, 0xed, 0x6a, 0x77, 0xc8, 0x9d, 0x1c, 0x86, 0x7e, 0x01, 0x8d, 0x45, 0x98,
	0x30, 0x22, 0xfc, 0xab, 0xd7, 0xf4, 0x37, 0xa5, 0x87, 0xc3, 0x7a, 0x63, 0x80, 0x4d, 0xca, 0xd0,
	0x5d, 0x68, 0xca, 0x1e, 0x93, 0x86, 0xe4, 0x0f, 0x24, 0x6f, 0x45, 0x45, 0x15, 0xda, 0x06, 0x20,
	0xf1, 0x82, 0x9e, 0xa4, 0x7c, 0xd3, 0x10, 0x0b, 0x9a, 0xbd, 0x36, 0xb4, 0x28, 0x09, 0xbd, 0x13,
	0xe2, 0xbb, 0xa2, 0xb3, 0xff, 0xca, 0x68, 0xb4, 0x3a, 0x1d, 0xfb, 0xdb, 0x1a, 0xd4, 0x55, 0x0a,
	0xcf, 0xd5, 0xab, 0x68, 0xa2, 0x62, 0x97, 0x8b, 0x24, 0xd4, 0xcb, 0xad, 0xe5, 0x35, 0xb9, 0xab,
	0x37, 0x23, 0xb7, 0x71, 0x6d, 0x72, 0x3f, 0xd5, 0x3c, 0x51, 0x95, 0xfb, 0xe9, 0x65, 0xbc, 0x2b,
	0xd0, 0x05, 0x93, 0x23, 0xcd, 0x97, 0xaf, 0xcf, 0x15, 0xef, 0xbd, 0x4b, 0xfd, 0x2f, 0x28, 0xdc,
	0x4d, 0x3b, 0x32, 0xaf, 0xd9, 0x8e, 0x4e, 0x97, 0x51, 0xe7, 0x6c, 0x19, 0xdd, 0x8c, 0xbf, 0x21,
	0x6c, 0x9d, 0xfa, 0xa9, 0x75, 0xc9, 0x94, 0x6f, 0x50, 0x32, 0x85, 0x0a, 0xac, 0x9c, 0xae, 0xc0,
	0xbd, 0x16, 0xc0, 0x62, 0xed, 0xd0, 0xfb, 0xf6, 0xff, 0x54, 0x2d, 0x45, 0xaa, 0x57, 0x6e, 0x48,
	0x75, 0xfb, 0x9f, 0x75, 0xa8, 0x1e, 0xbc, 0x70, 0x4e, 0x31, 0xae, 0x7c, 0x86, 0x71, 0x5d, 0x30,
	0x49, 0xec, 0xcd, 0x43, 0xa2, 0xfe, 0xa8, 0x81, 0x73, 0x51, 0x84, 0x66, 0xdc, 0xa3, 0xfc, 0x46,
	0x55, 0x26, 0x3d, 0x1c, 0x86, 0x1e, 0x43, 0x3d, 0xf5, 0xa8, 0xe8, 0x70, 0xc6, 0x65, 0xc7, 0x7b,
	0xf0, 0xc2, 0xe9, 0x4f, 0x25, 0x06, 0x6b, 0x2c, 0x7a, 0x04, 0xb5, 0xdf, 0x67, 0x84, 0x9e, 0x74,
	0x6b, 0x72, 0x36, 0xde, 0xbe, 0xd8, 0xe9, 0xd7, 0x02, 0x82, 0x15, 0xb2, 0x37, 0x83, 0xba, 0x5a,
	0x04, 0xb5, 0xa0, 0x7c, 0xac, 0x6f, 0x4e, 0xe5, 0x63, 0x71, 0x6b, 0xf5, 0xc2, 0x74, 0xe5, 0xe9,
	0xcb, 0x92, 0x12, 0xd0, 0x27, 0xd0, 0xf6, 0x03, 0xf6, 0x3b, 0x31, 0x8c, 0xdc, 0xd4, 0xe3, 0x2b,
	0xa6, 0xaf, 0x4b, 0x5b, 0xb9, 0x76, 0x2a, 0x94, 0xbd, 0xbf, 0x18, 0x50, 0x93, 0x51, 0xce, 0x15,
	0xef, 0xc7, 0xd0, 0xe6, 0x1e, 0x5d, 0x12, 0xee, 0x9e, 0x9e, 0xb9, 0x2d, 0xa5, 0x9d, 0xaa, 0xc9,
	0x6b, 0xc3, 0x96, 0xbc, 0x25, 0xbb, 0x82, 0xfc, 0x6e, 0x94, 0x47, 0x69, 0x4a, 0xa5, 0x38, 0xb3,
	0x57, 0xf2, 0x4e, 0xa7, 0x30, 0x8c, 0x93, 0x54, 0x1d, 0x93, 0x81, 0x41, 0xaa, 0x66, 0x42, 0x23,
	0xee, 0x9c, 0x3a, 0x06, 0x93, 0xe7, 0x61, 0x61, 0x53, 0x0d, 0x76, 0x86, 0xbe, 0x16, 0xa5, 0x1f,
	0x2c, 0x97, 0x44, 0xdd, 0x61, 0xdb, 0x83, 0x8f, 0xde, 0x73, 0x52, 0x7d, 0x47, 0x41, 0x71, 0xee,
	0x83, 0x1e, 0x83, 0xc1, 0x4f, 0xd2, 0x7c, 0x84, 0xde, 0x7d, 0xaf, 0xef, 0x49, 0x4a, 0xb0, 0x44,
	0xa3, 0xa7, 0x50, 0xa7, 0xf2, 0x61, 0x20, 0x67, 0x69, 0x7b, 0x60, 0xbf, 0xcf, 0x4f, 0x3d, 0x21,
	0xb0, 0xf6, 0x10, 0x15, 0xc0, 0x48, 0x2c, 0xa9, 0x64, 0x5d, 0xb7, 0x02, 0x84, 0x83, 0xc3, 0xc4,
	0x93, 0x45, 0xff, 0x00, 0x32, 0xa1, 0xba, 0x3b, 0x1d, 0x75, 0x4a, 0x68, 0x0b, 0xac, 0x83, 0xd1,
	0x6c, 0x7f, 0x72, 0x38, 0xc4, 0xbf, 0xed, 0x94, 0xed, 0xcf, 0xc1, 0x10, 0xfb, 0x44, 0x4d, 0x30,
	0xf7, 0x27, 0x63, 0x67, 0x38, 0x76, 0x3a, 0x25, 0xd4, 0x82, 0xc6, 0x14, 0x4f, 0x0e, 0x47, 0x07,
	0x43, 0xdc, 0x29, 0x23, 0x0b, 0x6a, 0x87, 0xbb, 0x2f, 0x5f, 0x0f, 0x3b, 0x15, 0xfb, 0x29, 0xd4,
	0xd5, 0xee, 0x04, 0x7e, 0xf6, 0x7a, 0x7f, 0x7f, 0x38, 0x9b, 0x75, 0x4a, 0x02, 0x31, 0xc4, 0x78,
	0x22, 0xc0, 0x4d, 0x30, 0x9d, 0xd1, 0xab, 0xe1, 0xe4, 0xb5, 0xd3, 0xa9, 0x08, 0x61, 0x3a, 0x1c,
	0x1f, 0x8c, 0xc6, 0xcf, 0x3b, 0x55, 0x3b, 0x03, 0x98, 0x65, 0x73, 0x76, 0xc2, 0x38, 0x89, 0x18,
	0xfa, 0x25, 0x34, 0x37, 0x25, 0xaf, 0x2e, 0x7b, 0x57, 0x34, 0x12, 0x5c, 0x74, 0x40, 0x9f, 0x41,
	0xd5, 0x5f, 0xe5, 0xf7, 0xcd, 0x1f, 0x5d, 0x78, 0x9c, 0x58, 0x20, 0xec, 0x3f, 0x57, 0xa1, 0x26,
	0x7a, 0xa3, 0x6c, 0xfa, 0xf9, 0xdd, 0xbc, 0x7c, 0x59, 0xd3, 0xd7, 0x2f, 0xbc, 0xcd, 0xb5, 0x7d,
	0x07, 0x4c, 0xaa, 0xde, 0x00, 0x3a, 0xd6, 0x05, 0x4e, 0xfa, 0x91, 0x80, 0x73, 0x24, 0x7a, 0x06,
	0xc0, 0xd6, 0xbf, 0xaa, 0x1b, 0xc0, 0x45, 0xf7, 0x94, 0x35, 0x06, 0x17, 0xf0, 0xff, 0xdb, 0x70,
	0xfa, 0x0a, 0x40, 0x3c, 0x5b, 0x3c, 0x45, 0x94, 0xda, 0x55, 0x44, 0xc1, 0x96, 0x46, 0x3b, 0x0c,
	0x3d, 0x29, 0x34, 0xab, 0xfa, 0x95, 0x8e, 0xeb, 0x36, 0xf5, 0x10, 0x3e, 0x60, 0xb1, 0x97, 0xb2,
	0x55, 0xc2, 0x5d, 0x3f, 0xa3, 0xf2, 0xfd, 0x23, 0xea, 0x55, 0x3d, 0xff, 0x50, 0x6e, 0x3b, 0xd0,
	0xa6, 0x57, 0xec, 0xc1, 0x50, 0xcc, 0x75, 0x39, 0x9d, 0x00, 0xea, 0xbb, 0xfb, 0xce, 0xe8, 0x70,
	0xd8, 0x29, 0x89, 0xef, 0xfd, 0x97, 0x93, 0xd9, 0xf0, 0x40, 0xb1, 0x67, 0x32, 0x1d, 0x8e, 0x05,
	0x61, 0x24, 0x7b, 0x84, 0x41, 0xb2, 0x67, 0x43, 0x31, 0xe3, 0xc1, 0xc7, 0x60, 0x88, 0x51, 0x2e,
	0x98, 0x3c, 0x1a, 0x8f, 0x9c, 0xd1, 0xae, 0x33, 0xc1, 0x8a, 0xd8, 0x78, 0x38, 0x9b, 0x4e, 0xc6,
	0x92, 0xb5, 0x7b, 0xdd, 0x7f, 0xbc, 0xdd, 0x2e, 0x7f, 0xff, 0x76, 0xbb, 0xfc, 0x9f, 0xb7, 0xdb,
	0xe5, 0xef, 0xde, 0x6d, 0x97, 0xbe, 0x7f, 0xb7, 0x5d, 0xfa, 0xd7, 0xbb, 0xed, 0xd2, 0xbc, 0x2e,
	0xff, 0x6a, 0xe7, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd7, 0x2b, 0xfb, 0x74, 0x48, 0x10, 0x00,
	0x00,
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *ResultCounter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultCounter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Total))
	}
	if m.Ok != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Ok))
	}
	if m.Err != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Err))
	}
	return i, nil
}

func (m *SlidingCounter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlidingCounter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Over_1M != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_1M))
	}
	if m.Over_5M != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_5M))
	}
	if m.Over_15M != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_15M))
	}
	if m.Over_30M != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_30M))
	}
	if m.Over_1Hr != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_1Hr))
	}
	if m.Over_2Hr != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_2Hr))
	}
	if m.Over_4Hr != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_4Hr))
	}
	if m.Over_8Hr != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_8Hr))
	}
	if m.Over_12Hr != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_12Hr))
	}
	if m.Over_24Hr != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_24Hr))
	}
	return i, nil
}

func (m *DataGauge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataGauge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CumBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.CumBytes))
	}
	if m.CumPackets != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.CumPackets))
	}
	if m.InstBw != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.InstBw))
	}
	return i, nil
}

func (m *Runtime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Runtime) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Implementation) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Implementation)))
		i += copy(dAtA[i:], m.Implementation)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.PeerId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.PeerId)))
		i += copy(dAtA[i:], m.PeerId)
	}
	return i, nil
}

func (m *EndpointPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SrcMultiaddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.SrcMultiaddr)))
		i += copy(dAtA[i:], m.SrcMultiaddr)
	}
	if len(m.DstMultiaddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.DstMultiaddr)))
		i += copy(dAtA[i:], m.DstMultiaddr)
	}
	return i, nil
}

func (m *Traffic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Traffic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TrafficIn != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.TrafficIn.Size()))
		n1, err := m.TrafficIn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.TrafficOut != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.TrafficOut.Size()))
		n2, err := m.TrafficOut.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *StreamList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StreamIds) > 0 {
		for _, s := range m.StreamIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Streams) > 0 {
		for _, msg := range m.Streams {
			dAtA[i] = 0x12
			i++
			i = encodeVarintIntrospection(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.PeerId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.PeerId)))
		i += copy(dAtA[i:], m.PeerId)
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Status))
	}
	if len(m.TransportId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.TransportId)))
		i += copy(dAtA[i:], m.TransportId)
	}
	if m.Endpoints != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Endpoints.Size()))
		n3, err := m.Endpoints.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Timeline != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Timeline.Size()))
		n4, err := m.Timeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Role != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Role))
	}
	if m.Traffic != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Traffic.Size()))
		n5, err := m.Traffic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Attribs != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Attribs.Size()))
		n6, err := m.Attribs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.LatencyNs != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.LatencyNs))
	}
	if m.Streams != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Streams.Size()))
		n7, err := m.Streams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.RelayedOver != nil {
		nn8, err := m.RelayedOver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	if len(m.UserProvidedTags) > 0 {
		for _, s := range m.UserProvidedTags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Connection_ConnId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintIntrospection(dAtA, i, uint64(len(m.ConnId)))
	i += copy(dAtA[i:], m.ConnId)
	return i, nil
}
func (m *Connection_Conn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Conn != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Conn.Size()))
		n9, err := m.Conn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Connection_Timeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection_Timeline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenTs != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.OpenTs)))
		n10, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.OpenTs, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.UpgradedTs != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpgradedTs)))
		n11, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpgradedTs, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.CloseTs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.CloseTs)))
		n12, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CloseTs, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *Connection_Attributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection_Attributes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Multiplexer) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Multiplexer)))
		i += copy(dAtA[i:], m.Multiplexer)
	}
	if len(m.Encryption) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Encryption)))
		i += copy(dAtA[i:], m.Encryption)
	}
	return i, nil
}

func (m *Stream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.Role != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Role))
	}
	if m.Traffic != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Traffic.Size()))
		n13, err := m.Traffic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Conn != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Conn.Size()))
		n14, err := m.Conn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Timeline != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Timeline.Size()))
		n15, err := m.Timeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Status != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Status))
	}
	if m.LatencyNs != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.LatencyNs))
	}
	if len(m.UserProvidedTags) > 0 {
		for _, s := range m.UserProvidedTags {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x6
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Stream_ConnectionRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream_ConnectionRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Connection != nil {
		nn16, err := m.Connection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	return i, nil
}

func (m *Stream_ConnectionRef_Conn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Conn != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Conn.Size()))
		n17, err := m.Conn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *Stream_ConnectionRef_ConnId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintIntrospection(dAtA, i, uint64(len(m.ConnId)))
	i += copy(dAtA[i:], m.ConnId)
	return i, nil
}
func (m *Stream_Timeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream_Timeline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenTs != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.OpenTs)))
		n18, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.OpenTs, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.CloseTs != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.CloseTs)))
		n19, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CloseTs, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *DHT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.Enabled {
		dAtA[i] = 0x10
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StartTs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTs)))
		n20, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StartTs, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Params != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Params.Size()))
		n21, err := m.Params.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Query) > 0 {
		for _, msg := range m.Query {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintIntrospection(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DHT_Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHT_Params) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.K != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.K))
	}
	if m.Alpha != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Alpha))
	}
	if m.DisjointPaths != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.DisjointPaths))
	}
	return i, nil
}

func (m *DHT_Query) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHT_Query) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.TargetPeerId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.TargetPeerId)))
		i += copy(dAtA[i:], m.TargetPeerId)
	}
	if m.TotalTimeMs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.TotalTimeMs))
	}
	if m.TotalSteps != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.TotalSteps))
	}
	if len(m.PeerIds) > 0 {
		for _, s := range m.PeerIds {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Trigger != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Trigger))
	}
	if m.Type != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Type))
	}
	if m.Result != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Result))
	}
	if m.SentTs != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.SentTs)))
		n22, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.SentTs, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *Subsystems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subsystems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Connections) > 0 {
		for _, msg := range m.Connections {
			dAtA[i] = 0xa
			i++
			i = encodeVarintIntrospection(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Dht != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Dht.Size()))
		n23, err := m.Dht.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *State) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *State) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Version.Size()))
		n24, err := m.Version.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Runtime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Runtime.Size()))
		n25, err := m.Runtime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Subsystems != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Subsystems.Size()))
		n26, err := m.Subsystems.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Traffic != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Traffic.Size()))
		n27, err := m.Traffic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.InstantTs != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.InstantTs.Size()))
		n28, err := m.InstantTs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.StartTs != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.StartTs.Size()))
		n29, err := m.StartTs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.SnapshotDurationMs != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintIntrospection(dAtA, i, uint64(m.SnapshotDurationMs))
	}
	return i, nil
}

func encodeVarintIntrospection(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovIntrospection(uint64(m.Number))
	}
	return n
}

func (m *ResultCounter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovIntrospection(uint64(m.Total))
	}
	if m.Ok != 0 {
		n += 1 + sovIntrospection(uint64(m.Ok))
	}
	if m.Err != 0 {
		n += 1 + sovIntrospection(uint64(m.Err))
	}
	return n
}

func (m *SlidingCounter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Over_1M != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_1M))
	}
	if m.Over_5M != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_5M))
	}
	if m.Over_15M != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_15M))
	}
	if m.Over_30M != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_30M))
	}
	if m.Over_1Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_1Hr))
	}
	if m.Over_2Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_2Hr))
	}
	if m.Over_4Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_4Hr))
	}
	if m.Over_8Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_8Hr))
	}
	if m.Over_12Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_12Hr))
	}
	if m.Over_24Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_24Hr))
	}
	return n
}

func (m *DataGauge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CumBytes != 0 {
		n += 1 + sovIntrospection(uint64(m.CumBytes))
	}
	if m.CumPackets != 0 {
		n += 1 + sovIntrospection(uint64(m.CumPackets))
	}
	if m.InstBw != 0 {
		n += 1 + sovIntrospection(uint64(m.InstBw))
	}
	return n
}

func (m *Runtime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Implementation)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *EndpointPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SrcMultiaddr)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.DstMultiaddr)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *Traffic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrafficIn != nil {
		l = m.TrafficIn.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.TrafficOut != nil {
		l = m.TrafficOut.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *StreamList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StreamIds) > 0 {
		for _, s := range m.StreamIds {
			l = len(s)
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *Connection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovIntrospection(uint64(m.Status))
	}
	l = len(m.TransportId)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Endpoints != nil {
		l = m.Endpoints.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Timeline != nil {
		l = m.Timeline.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovIntrospection(uint64(m.Role))
	}
	if m.Traffic != nil {
		l = m.Traffic.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Attribs != nil {
		l = m.Attribs.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.LatencyNs != 0 {
		n += 1 + sovIntrospection(uint64(m.LatencyNs))
	}
	if m.Streams != nil {
		l = m.Streams.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.RelayedOver != nil {
		n += m.RelayedOver.Size()
	}
	if len(m.UserProvidedTags) > 0 {
		for _, s := range m.UserProvidedTags {
			l = len(s)
			n += 2 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *Connection_ConnId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConnId)
	n += 2 + l + sovIntrospection(uint64(l))
	return n
}
func (m *Connection_Conn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Conn != nil {
		l = m.Conn.Size()
		n += 2 + l + sovIntrospection(uint64(l))
	}
	return n
}
func (m *Connection_Timeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenTs != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.OpenTs)
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.UpgradedTs != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpgradedTs)
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.CloseTs != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CloseTs)
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *Connection_Attributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Multiplexer)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.Encryption)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *Stream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovIntrospection(uint64(m.Role))
	}
	if m.Traffic != nil {
		l = m.Traffic.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Conn != nil {
		l = m.Conn.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Timeline != nil {
		l = m.Timeline.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovIntrospection(uint64(m.Status))
	}
	if m.LatencyNs != 0 {
		n += 2 + sovIntrospection(uint64(m.LatencyNs))
	}
	if len(m.UserProvidedTags) > 0 {
		for _, s := range m.UserProvidedTags {
			l = len(s)
			n += 2 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *Stream_ConnectionRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connection != nil {
		n += m.Connection.Size()
	}
	return n
}

func (m *Stream_ConnectionRef_Conn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Conn != nil {
		l = m.Conn.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}
func (m *Stream_ConnectionRef_ConnId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConnId)
	n += 1 + l + sovIntrospection(uint64(l))
	return n
}
func (m *Stream_Timeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenTs != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.OpenTs)
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.CloseTs != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CloseTs)
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *DHT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.StartTs != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartTs)
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if len(m.Query) > 0 {
		for _, e := range m.Query {
			l = e.Size()
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *DHT_Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K != 0 {
		n += 1 + sovIntrospection(uint64(m.K))
	}
	if m.Alpha != 0 {
		n += 1 + sovIntrospection(uint64(m.Alpha))
	}
	if m.DisjointPaths != 0 {
		n += 1 + sovIntrospection(uint64(m.DisjointPaths))
	}
	return n
}

func (m *DHT_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.TargetPeerId)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.TotalTimeMs != 0 {
		n += 1 + sovIntrospection(uint64(m.TotalTimeMs))
	}
	if m.TotalSteps != 0 {
		n += 1 + sovIntrospection(uint64(m.TotalSteps))
	}
	if len(m.PeerIds) > 0 {
		for _, s := range m.PeerIds {
			l = len(s)
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	if m.Trigger != 0 {
		n += 1 + sovIntrospection(uint64(m.Trigger))
	}
	if m.Type != 0 {
		n += 1 + sovIntrospection(uint64(m.Type))
	}
	if m.Result != 0 {
		n += 1 + sovIntrospection(uint64(m.Result))
	}
	if m.SentTs != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.SentTs)
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *Subsystems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Connections) > 0 {
		for _, e := range m.Connections {
			l = e.Size()
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	if m.Dht != nil {
		l = m.Dht.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *State) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Runtime != nil {
		l = m.Runtime.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Subsystems != nil {
		l = m.Subsystems.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Traffic != nil {
		l = m.Traffic.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.InstantTs != nil {
		l = m.InstantTs.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.StartTs != nil {
		l = m.StartTs.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.SnapshotDurationMs != 0 {
		n += 1 + sovIntrospection(uint64(m.SnapshotDurationMs))
	}
	return n
}

func sovIntrospection(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozIntrospection(x uint64) (n int) {
	return sovIntrospection(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultCounter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultCounter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultCounter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			m.Ok = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ok |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlidingCounter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlidingCounter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlidingCounter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_1M", wireType)
			}
			m.Over_1M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_1M |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_5M", wireType)
			}
			m.Over_5M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_5M |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_15M", wireType)
			}
			m.Over_15M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_15M |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_30M", wireType)
			}
			m.Over_30M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_30M |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_1Hr", wireType)
			}
			m.Over_1Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_1Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_2Hr", wireType)
			}
			m.Over_2Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_2Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_4Hr", wireType)
			}
			m.Over_4Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_4Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_8Hr", wireType)
			}
			m.Over_8Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_8Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_12Hr", wireType)
			}
			m.Over_12Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_12Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_24Hr", wireType)
			}
			m.Over_24Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_24Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataGauge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataGauge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataGauge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumBytes", wireType)
			}
			m.CumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CumBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumPackets", wireType)
			}
			m.CumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CumPackets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstBw", wireType)
			}
			m.InstBw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstBw |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Runtime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Runtime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Runtime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implementation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Implementation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMultiaddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMultiaddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMultiaddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMultiaddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Traffic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Traffic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Traffic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficIn == nil {
				m.TrafficIn = &DataGauge{}
			}
			if err := m.TrafficIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficOut == nil {
				m.TrafficOut = &DataGauge{}
			}
			if err := m.TrafficOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamIds = append(m.StreamIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, &Stream{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransportId = append(m.TransportId[:0], dAtA[iNdEx:postIndex]...)
			if m.TransportId == nil {
				m.TransportId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoints == nil {
				m.Endpoints = &EndpointPair{}
			}
			if err := m.Endpoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeline == nil {
				m.Timeline = &Connection_Timeline{}
			}
			if err := m.Timeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traffic == nil {
				m.Traffic = &Traffic{}
			}
			if err := m.Traffic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attribs == nil {
				m.Attribs = &Connection_Attributes{}
			}
			if err := m.Attribs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyNs", wireType)
			}
			m.LatencyNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatencyNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Streams == nil {
				m.Streams = &StreamList{}
			}
			if err := m.Streams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayedOver = &Connection_ConnId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Connection{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RelayedOver = &Connection_Conn{v}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProvidedTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProvidedTags = append(m.UserProvidedTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection_Timeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenTs == nil {
				m.OpenTs = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.OpenTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradedTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradedTs == nil {
				m.UpgradedTs = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpgradedTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseTs == nil {
				m.CloseTs = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CloseTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection_Attributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplexer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Multiplexer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encryption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traffic == nil {
				m.Traffic = &Traffic{}
			}
			if err := m.Traffic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conn == nil {
				m.Conn = &Stream_ConnectionRef{}
			}
			if err := m.Conn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeline == nil {
				m.Timeline = &Stream_Timeline{}
			}
			if err := m.Timeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyNs", wireType)
			}
			m.LatencyNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatencyNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProvidedTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProvidedTags = append(m.UserProvidedTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream_ConnectionRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Connection{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Connection = &Stream_ConnectionRef_Conn{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connection = &Stream_ConnectionRef_ConnId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream_Timeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenTs == nil {
				m.OpenTs = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.OpenTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseTs == nil {
				m.CloseTs = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CloseTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTs == nil {
				m.StartTs = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StartTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &DHT_Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = append(m.Query, &DHT_Query{})
			if err := m.Query[len(m.Query)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHT_Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alpha", wireType)
			}
			m.Alpha = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alpha |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisjointPaths", wireType)
			}
			m.DisjointPaths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisjointPaths |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHT_Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetPeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTimeMs", wireType)
			}
			m.TotalTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTimeMs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSteps", wireType)
			}
			m.TotalSteps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSteps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerIds = append(m.PeerIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			m.Trigger = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Trigger |= DHT_Query_Trigger(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DHT_Query_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= DHT_Query_Result(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SentTs == nil {
				m.SentTs = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.SentTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subsystems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subsystems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subsystems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connections = append(m.Connections, &Connection{})
			if err := m.Connections[len(m.Connections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dht", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dht == nil {
				m.Dht = &DHT{}
			}
			if err := m.Dht.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Runtime == nil {
				m.Runtime = &Runtime{}
			}
			if err := m.Runtime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsystems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subsystems == nil {
				m.Subsystems = &Subsystems{}
			}
			if err := m.Subsystems.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traffic == nil {
				m.Traffic = &Traffic{}
			}
			if err := m.Traffic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstantTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InstantTs == nil {
				m.InstantTs = &types.Timestamp{}
			}
			if err := m.InstantTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTs == nil {
				m.StartTs = &types.Timestamp{}
			}
			if err := m.StartTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotDurationMs", wireType)
			}
			m.SnapshotDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIntrospection(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIntrospection
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthIntrospection
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowIntrospection
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipIntrospection(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthIntrospection
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthIntrospection = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIntrospection   = fmt.Errorf("proto: integer overflow")
)
