// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: introspection.proto

package introspection

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The status of a connection or stream.
type Status int32

const (
	Status_ACTIVE  Status = 0
	Status_CLOSED  Status = 1
	Status_OPENING Status = 2
	Status_CLOSING Status = 3
	Status_ERROR   Status = 4
)

var Status_name = map[int32]string{
	0: "ACTIVE",
	1: "CLOSED",
	2: "OPENING",
	3: "CLOSING",
	4: "ERROR",
}

var Status_value = map[string]int32{
	"ACTIVE":  0,
	"CLOSED":  1,
	"OPENING": 2,
	"CLOSING": 3,
	"ERROR":   4,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{0}
}

// Our role in a connection or stream.
type Role int32

const (
	Role_INITIATOR Role = 0
	Role_RESPONDER Role = 1
)

var Role_name = map[int32]string{
	0: "INITIATOR",
	1: "RESPONDER",
}

var Role_value = map[string]int32{
	"INITIATOR": 0,
	"RESPONDER": 1,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}

func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{1}
}

// tells client how to sort, filter or display known content properties
type EventType_EventProperty_PropertyType int32

const (
	// for properties to treat as a simple primitive
	EventType_EventProperty_STRING EventType_EventProperty_PropertyType = 0
	EventType_EventProperty_NUMBER EventType_EventProperty_PropertyType = 1
	// for properties with special human-readable formatting
	EventType_EventProperty_TIME      EventType_EventProperty_PropertyType = 10
	EventType_EventProperty_PEERID    EventType_EventProperty_PropertyType = 11
	EventType_EventProperty_MULTIADDR EventType_EventProperty_PropertyType = 12
	// for complex structures like nested arrays, object trees etc
	EventType_EventProperty_JSON EventType_EventProperty_PropertyType = 90
)

var EventType_EventProperty_PropertyType_name = map[int32]string{
	0:  "STRING",
	1:  "NUMBER",
	10: "TIME",
	11: "PEERID",
	12: "MULTIADDR",
	90: "JSON",
}

var EventType_EventProperty_PropertyType_value = map[string]int32{
	"STRING":    0,
	"NUMBER":    1,
	"TIME":      10,
	"PEERID":    11,
	"MULTIADDR": 12,
	"JSON":      90,
}

func (x EventType_EventProperty_PropertyType) String() string {
	return proto.EnumName(EventType_EventProperty_PropertyType_name, int32(x))
}

func (EventType_EventProperty_PropertyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{4, 0, 0}
}

// The DHT's relationship with this peer
type DHT_PeerInDHT_Status int32

const (
	// Connected, in a bucket, ready to send/receive queries
	DHT_PeerInDHT_ACTIVE DHT_PeerInDHT_Status = 0
	// Not currently connected, still "in" a bucket (e.g. temporarily disconnected)
	DHT_PeerInDHT_MISSING DHT_PeerInDHT_Status = 1
	// Removed from a bucket or candidate list (e.g. connection lost or too slow)
	DHT_PeerInDHT_REJECTED DHT_PeerInDHT_Status = 2
	// Was reachable when last checked, waiting to join a currently-full bucket
	DHT_PeerInDHT_CANDIDATE DHT_PeerInDHT_Status = 3
)

var DHT_PeerInDHT_Status_name = map[int32]string{
	0: "ACTIVE",
	1: "MISSING",
	2: "REJECTED",
	3: "CANDIDATE",
}

var DHT_PeerInDHT_Status_value = map[string]int32{
	"ACTIVE":    0,
	"MISSING":   1,
	"REJECTED":  2,
	"CANDIDATE": 3,
}

func (x DHT_PeerInDHT_Status) String() string {
	return proto.EnumName(DHT_PeerInDHT_Status_name, int32(x))
}

func (DHT_PeerInDHT_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{11, 1, 0}
}

// The signal to be sent to the server
type ClientSignal_Signal int32

const (
	// SEND_DATA with `data_source` requests messages from pull-based data emitters
	ClientSignal_SEND_DATA ClientSignal_Signal = 0
	// PAUSE_ & UNPAUSE_PUSH_EMITTER allows control of push-based data emitters
	ClientSignal_PAUSE_PUSH_EMITTER   ClientSignal_Signal = 1
	ClientSignal_UNPAUSE_PUSH_EMITTER ClientSignal_Signal = 2
	// CONFIG_EMITTER with `content` sends a JSON object of settings to the emitter
	ClientSignal_CONFIG_EMITTER ClientSignal_Signal = 10
)

var ClientSignal_Signal_name = map[int32]string{
	0:  "SEND_DATA",
	1:  "PAUSE_PUSH_EMITTER",
	2:  "UNPAUSE_PUSH_EMITTER",
	10: "CONFIG_EMITTER",
}

var ClientSignal_Signal_value = map[string]int32{
	"SEND_DATA":            0,
	"PAUSE_PUSH_EMITTER":   1,
	"UNPAUSE_PUSH_EMITTER": 2,
	"CONFIG_EMITTER":       10,
}

func (x ClientSignal_Signal) String() string {
	return proto.EnumName(ClientSignal_Signal_name, int32(x))
}

func (ClientSignal_Signal) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{16, 0}
}

// The source the data is expected to come from
type ClientSignal_DataSource int32

const (
	ClientSignal_STATE   ClientSignal_DataSource = 0
	ClientSignal_RUNTIME ClientSignal_DataSource = 1
)

var ClientSignal_DataSource_name = map[int32]string{
	0: "STATE",
	1: "RUNTIME",
}

var ClientSignal_DataSource_value = map[string]int32{
	"STATE":   0,
	"RUNTIME": 1,
}

func (x ClientSignal_DataSource) String() string {
	return proto.EnumName(ClientSignal_DataSource_name, int32(x))
}

func (ClientSignal_DataSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{16, 1}
}

// Version of schema
type Version struct {
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{0}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// ResultCounter is a monotonically increasing counter that reports an ok/err breakdown of the total.
type ResultCounter struct {
	Total uint32 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Ok    uint32 `protobuf:"varint,2,opt,name=ok,proto3" json:"ok,omitempty"`
	Err   uint32 `protobuf:"varint,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *ResultCounter) Reset()         { *m = ResultCounter{} }
func (m *ResultCounter) String() string { return proto.CompactTextString(m) }
func (*ResultCounter) ProtoMessage()    {}
func (*ResultCounter) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{1}
}
func (m *ResultCounter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultCounter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultCounter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultCounter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultCounter.Merge(m, src)
}
func (m *ResultCounter) XXX_Size() int {
	return m.Size()
}
func (m *ResultCounter) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultCounter.DiscardUnknown(m)
}

var xxx_messageInfo_ResultCounter proto.InternalMessageInfo

func (m *ResultCounter) GetTotal() uint32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ResultCounter) GetOk() uint32 {
	if m != nil {
		return m.Ok
	}
	return 0
}

func (m *ResultCounter) GetErr() uint32 {
	if m != nil {
		return m.Err
	}
	return 0
}

// Moving totals over sliding time windows. Models sensible time windows,
// we don't have to populate them all at once.
//
// Graphical example:
//
// time     past -> present                              an event 16 min ago
// ======================================================X================>>
//                                                       |               | 1m
//                                                       |           |---| 5m
//                                                       | |-------------| 15m
//                                          |------------X---------------| 30m
//            |------------------------------------------X---------------| 60m
type SlidingCounter struct {
	Over_1M   uint32 `protobuf:"varint,1,opt,name=over_1m,json=over1m,proto3" json:"over_1m,omitempty"`
	Over_5M   uint32 `protobuf:"varint,2,opt,name=over_5m,json=over5m,proto3" json:"over_5m,omitempty"`
	Over_15M  uint32 `protobuf:"varint,3,opt,name=over_15m,json=over15m,proto3" json:"over_15m,omitempty"`
	Over_30M  uint32 `protobuf:"varint,4,opt,name=over_30m,json=over30m,proto3" json:"over_30m,omitempty"`
	Over_1Hr  uint32 `protobuf:"varint,5,opt,name=over_1hr,json=over1hr,proto3" json:"over_1hr,omitempty"`
	Over_2Hr  uint32 `protobuf:"varint,6,opt,name=over_2hr,json=over2hr,proto3" json:"over_2hr,omitempty"`
	Over_4Hr  uint32 `protobuf:"varint,7,opt,name=over_4hr,json=over4hr,proto3" json:"over_4hr,omitempty"`
	Over_8Hr  uint32 `protobuf:"varint,8,opt,name=over_8hr,json=over8hr,proto3" json:"over_8hr,omitempty"`
	Over_12Hr uint32 `protobuf:"varint,9,opt,name=over_12hr,json=over12hr,proto3" json:"over_12hr,omitempty"`
	Over_24Hr uint32 `protobuf:"varint,10,opt,name=over_24hr,json=over24hr,proto3" json:"over_24hr,omitempty"`
}

func (m *SlidingCounter) Reset()         { *m = SlidingCounter{} }
func (m *SlidingCounter) String() string { return proto.CompactTextString(m) }
func (*SlidingCounter) ProtoMessage()    {}
func (*SlidingCounter) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{2}
}
func (m *SlidingCounter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlidingCounter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlidingCounter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlidingCounter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlidingCounter.Merge(m, src)
}
func (m *SlidingCounter) XXX_Size() int {
	return m.Size()
}
func (m *SlidingCounter) XXX_DiscardUnknown() {
	xxx_messageInfo_SlidingCounter.DiscardUnknown(m)
}

var xxx_messageInfo_SlidingCounter proto.InternalMessageInfo

func (m *SlidingCounter) GetOver_1M() uint32 {
	if m != nil {
		return m.Over_1M
	}
	return 0
}

func (m *SlidingCounter) GetOver_5M() uint32 {
	if m != nil {
		return m.Over_5M
	}
	return 0
}

func (m *SlidingCounter) GetOver_15M() uint32 {
	if m != nil {
		return m.Over_15M
	}
	return 0
}

func (m *SlidingCounter) GetOver_30M() uint32 {
	if m != nil {
		return m.Over_30M
	}
	return 0
}

func (m *SlidingCounter) GetOver_1Hr() uint32 {
	if m != nil {
		return m.Over_1Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_2Hr() uint32 {
	if m != nil {
		return m.Over_2Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_4Hr() uint32 {
	if m != nil {
		return m.Over_4Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_8Hr() uint32 {
	if m != nil {
		return m.Over_8Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_12Hr() uint32 {
	if m != nil {
		return m.Over_12Hr
	}
	return 0
}

func (m *SlidingCounter) GetOver_24Hr() uint32 {
	if m != nil {
		return m.Over_24Hr
	}
	return 0
}

// DataGauge reports stats for data traffic in a given direction.
type DataGauge struct {
	// Cumulative bytes.
	CumBytes uint64 `protobuf:"varint,1,opt,name=cum_bytes,json=cumBytes,proto3" json:"cum_bytes,omitempty"`
	// Cumulative packets.
	CumPackets uint64 `protobuf:"varint,2,opt,name=cum_packets,json=cumPackets,proto3" json:"cum_packets,omitempty"`
	// Instantaneous bandwidth measurement (bytes/second).
	InstBw uint64 `protobuf:"varint,3,opt,name=inst_bw,json=instBw,proto3" json:"inst_bw,omitempty"`
}

func (m *DataGauge) Reset()         { *m = DataGauge{} }
func (m *DataGauge) String() string { return proto.CompactTextString(m) }
func (*DataGauge) ProtoMessage()    {}
func (*DataGauge) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{3}
}
func (m *DataGauge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataGauge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataGauge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataGauge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataGauge.Merge(m, src)
}
func (m *DataGauge) XXX_Size() int {
	return m.Size()
}
func (m *DataGauge) XXX_DiscardUnknown() {
	xxx_messageInfo_DataGauge.DiscardUnknown(m)
}

var xxx_messageInfo_DataGauge proto.InternalMessageInfo

func (m *DataGauge) GetCumBytes() uint64 {
	if m != nil {
		return m.CumBytes
	}
	return 0
}

func (m *DataGauge) GetCumPackets() uint64 {
	if m != nil {
		return m.CumPackets
	}
	return 0
}

func (m *DataGauge) GetInstBw() uint64 {
	if m != nil {
		return m.InstBw
	}
	return 0
}

// describes a type of event
type EventType struct {
	// name of event type, e.g. PeerConnecting
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// for runtime, send property_types for all events already seen in events list
	// for events, only send property_types in the first event of a type not in runtime
	PropertyTypes []*EventType_EventProperty `protobuf:"bytes,2,rep,name=property_types,json=propertyTypes,proto3" json:"property_types,omitempty"`
}

func (m *EventType) Reset()         { *m = EventType{} }
func (m *EventType) String() string { return proto.CompactTextString(m) }
func (*EventType) ProtoMessage()    {}
func (*EventType) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{4}
}
func (m *EventType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventType.Merge(m, src)
}
func (m *EventType) XXX_Size() int {
	return m.Size()
}
func (m *EventType) XXX_DiscardUnknown() {
	xxx_messageInfo_EventType.DiscardUnknown(m)
}

var xxx_messageInfo_EventType proto.InternalMessageInfo

func (m *EventType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventType) GetPropertyTypes() []*EventType_EventProperty {
	if m != nil {
		return m.PropertyTypes
	}
	return nil
}

// metadata about content types in event's top-level content JSON
type EventType_EventProperty struct {
	// property name of content e.g. openTs
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// type to interpret content value as
	Type EventType_EventProperty_PropertyType `protobuf:"varint,2,opt,name=type,proto3,enum=introspection.EventType_EventProperty_PropertyType" json:"type,omitempty"`
	// if true, expect an array of values of `type`; else, singular
	HasMultiple bool `protobuf:"varint,3,opt,name=has_multiple,json=hasMultiple,proto3" json:"has_multiple,omitempty"`
}

func (m *EventType_EventProperty) Reset()         { *m = EventType_EventProperty{} }
func (m *EventType_EventProperty) String() string { return proto.CompactTextString(m) }
func (*EventType_EventProperty) ProtoMessage()    {}
func (*EventType_EventProperty) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{4, 0}
}
func (m *EventType_EventProperty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventType_EventProperty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventType_EventProperty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventType_EventProperty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventType_EventProperty.Merge(m, src)
}
func (m *EventType_EventProperty) XXX_Size() int {
	return m.Size()
}
func (m *EventType_EventProperty) XXX_DiscardUnknown() {
	xxx_messageInfo_EventType_EventProperty.DiscardUnknown(m)
}

var xxx_messageInfo_EventType_EventProperty proto.InternalMessageInfo

func (m *EventType_EventProperty) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventType_EventProperty) GetType() EventType_EventProperty_PropertyType {
	if m != nil {
		return m.Type
	}
	return EventType_EventProperty_STRING
}

func (m *EventType_EventProperty) GetHasMultiple() bool {
	if m != nil {
		return m.HasMultiple
	}
	return false
}

// Runtime encapsulates runtime info about a node.
type Runtime struct {
	// e.g. go-libp2p, js-libp2p, rust-libp2p, etc.
	Implementation string `protobuf:"bytes,1,opt,name=implementation,proto3" json:"implementation,omitempty"`
	// e.g. 1.2.3.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// e.g. Windows, Unix, macOS, Chrome, Mozilla, etc.
	Platform string `protobuf:"bytes,3,opt,name=platform,proto3" json:"platform,omitempty"`
	// our peer id - the peer id of the host system
	PeerId string `protobuf:"bytes,4,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	// length of time to keep stale data
	KeepStaleDataMs uint32 `protobuf:"varint,5,opt,name=keep_stale_data_ms,json=keepStaleDataMs,proto3" json:"keep_stale_data_ms,omitempty"`
	// frequency to send new states
	SendStateIntervalMs uint32 `protobuf:"varint,6,opt,name=send_state_interval_ms,json=sendStateIntervalMs,proto3" json:"send_state_interval_ms,omitempty"`
	// metadata describing configured event types
	EventTypes []*EventType `protobuf:"bytes,7,rep,name=event_types,json=eventTypes,proto3" json:"event_types,omitempty"`
}

func (m *Runtime) Reset()         { *m = Runtime{} }
func (m *Runtime) String() string { return proto.CompactTextString(m) }
func (*Runtime) ProtoMessage()    {}
func (*Runtime) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{5}
}
func (m *Runtime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Runtime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Runtime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Runtime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Runtime.Merge(m, src)
}
func (m *Runtime) XXX_Size() int {
	return m.Size()
}
func (m *Runtime) XXX_DiscardUnknown() {
	xxx_messageInfo_Runtime.DiscardUnknown(m)
}

var xxx_messageInfo_Runtime proto.InternalMessageInfo

func (m *Runtime) GetImplementation() string {
	if m != nil {
		return m.Implementation
	}
	return ""
}

func (m *Runtime) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Runtime) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *Runtime) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *Runtime) GetKeepStaleDataMs() uint32 {
	if m != nil {
		return m.KeepStaleDataMs
	}
	return 0
}

func (m *Runtime) GetSendStateIntervalMs() uint32 {
	if m != nil {
		return m.SendStateIntervalMs
	}
	return 0
}

func (m *Runtime) GetEventTypes() []*EventType {
	if m != nil {
		return m.EventTypes
	}
	return nil
}

// EndpointPair is a pair of multiaddrs.
type EndpointPair struct {
	// the source multiaddr.
	SrcMultiaddr string `protobuf:"bytes,1,opt,name=src_multiaddr,json=srcMultiaddr,proto3" json:"src_multiaddr,omitempty"`
	// the destination multiaddr.
	DstMultiaddr string `protobuf:"bytes,2,opt,name=dst_multiaddr,json=dstMultiaddr,proto3" json:"dst_multiaddr,omitempty"`
}

func (m *EndpointPair) Reset()         { *m = EndpointPair{} }
func (m *EndpointPair) String() string { return proto.CompactTextString(m) }
func (*EndpointPair) ProtoMessage()    {}
func (*EndpointPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{6}
}
func (m *EndpointPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndpointPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndpointPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndpointPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndpointPair.Merge(m, src)
}
func (m *EndpointPair) XXX_Size() int {
	return m.Size()
}
func (m *EndpointPair) XXX_DiscardUnknown() {
	xxx_messageInfo_EndpointPair.DiscardUnknown(m)
}

var xxx_messageInfo_EndpointPair proto.InternalMessageInfo

func (m *EndpointPair) GetSrcMultiaddr() string {
	if m != nil {
		return m.SrcMultiaddr
	}
	return ""
}

func (m *EndpointPair) GetDstMultiaddr() string {
	if m != nil {
		return m.DstMultiaddr
	}
	return ""
}

// Traffic encloses data transfer statistics.
type Traffic struct {
	// snapshot of the data in metrics.
	TrafficIn *DataGauge `protobuf:"bytes,1,opt,name=traffic_in,json=trafficIn,proto3" json:"traffic_in,omitempty"`
	// snapshot of the data out metrics.
	TrafficOut *DataGauge `protobuf:"bytes,2,opt,name=traffic_out,json=trafficOut,proto3" json:"traffic_out,omitempty"`
}

func (m *Traffic) Reset()         { *m = Traffic{} }
func (m *Traffic) String() string { return proto.CompactTextString(m) }
func (*Traffic) ProtoMessage()    {}
func (*Traffic) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{7}
}
func (m *Traffic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Traffic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Traffic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Traffic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Traffic.Merge(m, src)
}
func (m *Traffic) XXX_Size() int {
	return m.Size()
}
func (m *Traffic) XXX_DiscardUnknown() {
	xxx_messageInfo_Traffic.DiscardUnknown(m)
}

var xxx_messageInfo_Traffic proto.InternalMessageInfo

func (m *Traffic) GetTrafficIn() *DataGauge {
	if m != nil {
		return m.TrafficIn
	}
	return nil
}

func (m *Traffic) GetTrafficOut() *DataGauge {
	if m != nil {
		return m.TrafficOut
	}
	return nil
}

// a list of streams, by reference or inlined.
type StreamList struct {
	// NOTE: only one of the next 2 fields can appear, but proto3
	// doesn't support combining oneof and repeated.
	//
	// streams within this connection by reference.
	StreamIds [][]byte `protobuf:"bytes,1,rep,name=stream_ids,json=streamIds,proto3" json:"stream_ids,omitempty"`
	// streams within this connection by inlining.
	Streams []*Stream `protobuf:"bytes,2,rep,name=streams,proto3" json:"streams,omitempty"`
}

func (m *StreamList) Reset()         { *m = StreamList{} }
func (m *StreamList) String() string { return proto.CompactTextString(m) }
func (*StreamList) ProtoMessage()    {}
func (*StreamList) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{8}
}
func (m *StreamList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamList.Merge(m, src)
}
func (m *StreamList) XXX_Size() int {
	return m.Size()
}
func (m *StreamList) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamList.DiscardUnknown(m)
}

var xxx_messageInfo_StreamList proto.InternalMessageInfo

func (m *StreamList) GetStreamIds() [][]byte {
	if m != nil {
		return m.StreamIds
	}
	return nil
}

func (m *StreamList) GetStreams() []*Stream {
	if m != nil {
		return m.Streams
	}
	return nil
}

// Connection reports metrics and state of a libp2p connection.
type Connection struct {
	// the id of this connection, not to be shown in user tooling,
	// used for (cross)referencing connections (e.g. relay).
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the peer id of the other party.
	PeerId string `protobuf:"bytes,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	// the status of this connection.
	Status Status `protobuf:"varint,3,opt,name=status,proto3,enum=introspection.Status" json:"status,omitempty"`
	// a reference to the transport managing this connection.
	TransportId []byte `protobuf:"bytes,4,opt,name=transport_id,json=transportId,proto3" json:"transport_id,omitempty"`
	// the endpoints participating in this connection.
	Endpoints *EndpointPair `protobuf:"bytes,5,opt,name=endpoints,proto3" json:"endpoints,omitempty"`
	// the timeline of the connection, see Connection.Timeline.
	Timeline *Connection_Timeline `protobuf:"bytes,6,opt,name=timeline,proto3" json:"timeline,omitempty"`
	// our role in this connection.
	Role Role `protobuf:"varint,7,opt,name=role,proto3,enum=introspection.Role" json:"role,omitempty"`
	// traffic statistics.
	Traffic *Traffic `protobuf:"bytes,8,opt,name=traffic,proto3" json:"traffic,omitempty"`
	// properties of this connection.
	Attribs *Connection_Attributes `protobuf:"bytes,9,opt,name=attribs,proto3" json:"attribs,omitempty"`
	// the instantaneous latency of this connection in nanoseconds.
	LatencyNs uint64 `protobuf:"varint,10,opt,name=latency_ns,json=latencyNs,proto3" json:"latency_ns,omitempty"`
	// streams within this connection.
	Streams *StreamList `protobuf:"bytes,11,opt,name=streams,proto3" json:"streams,omitempty"`
	// if this is a relayed connection, this points to the relaying connection.
	// a default value here (empty bytes) indicates this is not a relayed connection.
	//
	// Types that are valid to be assigned to RelayedOver:
	//	*Connection_ConnId
	//	*Connection_Conn
	RelayedOver isConnection_RelayedOver `protobuf_oneof:"relayed_over"`
	// user provided tags.
	UserProvidedTags []string `protobuf:"bytes,99,rep,name=user_provided_tags,json=userProvidedTags,proto3" json:"user_provided_tags,omitempty"`
}

func (m *Connection) Reset()         { *m = Connection{} }
func (m *Connection) String() string { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()    {}
func (*Connection) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{9}
}
func (m *Connection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection.Merge(m, src)
}
func (m *Connection) XXX_Size() int {
	return m.Size()
}
func (m *Connection) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection.DiscardUnknown(m)
}

var xxx_messageInfo_Connection proto.InternalMessageInfo

type isConnection_RelayedOver interface {
	isConnection_RelayedOver()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Connection_ConnId struct {
	ConnId []byte `protobuf:"bytes,16,opt,name=conn_id,json=connId,proto3,oneof" json:"conn_id,omitempty"`
}
type Connection_Conn struct {
	Conn *Connection `protobuf:"bytes,17,opt,name=conn,proto3,oneof" json:"conn,omitempty"`
}

func (*Connection_ConnId) isConnection_RelayedOver() {}
func (*Connection_Conn) isConnection_RelayedOver()   {}

func (m *Connection) GetRelayedOver() isConnection_RelayedOver {
	if m != nil {
		return m.RelayedOver
	}
	return nil
}

func (m *Connection) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Connection) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *Connection) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_ACTIVE
}

func (m *Connection) GetTransportId() []byte {
	if m != nil {
		return m.TransportId
	}
	return nil
}

func (m *Connection) GetEndpoints() *EndpointPair {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *Connection) GetTimeline() *Connection_Timeline {
	if m != nil {
		return m.Timeline
	}
	return nil
}

func (m *Connection) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_INITIATOR
}

func (m *Connection) GetTraffic() *Traffic {
	if m != nil {
		return m.Traffic
	}
	return nil
}

func (m *Connection) GetAttribs() *Connection_Attributes {
	if m != nil {
		return m.Attribs
	}
	return nil
}

func (m *Connection) GetLatencyNs() uint64 {
	if m != nil {
		return m.LatencyNs
	}
	return 0
}

func (m *Connection) GetStreams() *StreamList {
	if m != nil {
		return m.Streams
	}
	return nil
}

func (m *Connection) GetConnId() []byte {
	if x, ok := m.GetRelayedOver().(*Connection_ConnId); ok {
		return x.ConnId
	}
	return nil
}

func (m *Connection) GetConn() *Connection {
	if x, ok := m.GetRelayedOver().(*Connection_Conn); ok {
		return x.Conn
	}
	return nil
}

func (m *Connection) GetUserProvidedTags() []string {
	if m != nil {
		return m.UserProvidedTags
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Connection) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Connection_ConnId)(nil),
		(*Connection_Conn)(nil),
	}
}

// Timeline contains the timestamps (ms since epoch) of the well-known milestones of a connection.
type Connection_Timeline struct {
	// the instant when a connection was opened on the wire.
	OpenTs uint64 `protobuf:"varint,1,opt,name=open_ts,json=openTs,proto3" json:"open_ts,omitempty"`
	// the instant when the upgrade process (handshake, security, multiplexing) finished.
	UpgradedTs uint64 `protobuf:"varint,2,opt,name=upgraded_ts,json=upgradedTs,proto3" json:"upgraded_ts,omitempty"`
	// the instant when this connection was terminated.
	CloseTs uint64 `protobuf:"varint,3,opt,name=close_ts,json=closeTs,proto3" json:"close_ts,omitempty"`
}

func (m *Connection_Timeline) Reset()         { *m = Connection_Timeline{} }
func (m *Connection_Timeline) String() string { return proto.CompactTextString(m) }
func (*Connection_Timeline) ProtoMessage()    {}
func (*Connection_Timeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{9, 0}
}
func (m *Connection_Timeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection_Timeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection_Timeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection_Timeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection_Timeline.Merge(m, src)
}
func (m *Connection_Timeline) XXX_Size() int {
	return m.Size()
}
func (m *Connection_Timeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection_Timeline.DiscardUnknown(m)
}

var xxx_messageInfo_Connection_Timeline proto.InternalMessageInfo

func (m *Connection_Timeline) GetOpenTs() uint64 {
	if m != nil {
		return m.OpenTs
	}
	return 0
}

func (m *Connection_Timeline) GetUpgradedTs() uint64 {
	if m != nil {
		return m.UpgradedTs
	}
	return 0
}

func (m *Connection_Timeline) GetCloseTs() uint64 {
	if m != nil {
		return m.CloseTs
	}
	return 0
}

// Attributes encapsulates the attributes of this connection.
type Connection_Attributes struct {
	// the multiplexer being used.
	Multiplexer string `protobuf:"bytes,1,opt,name=multiplexer,proto3" json:"multiplexer,omitempty"`
	// the encryption method being used.
	Encryption string `protobuf:"bytes,2,opt,name=encryption,proto3" json:"encryption,omitempty"`
}

func (m *Connection_Attributes) Reset()         { *m = Connection_Attributes{} }
func (m *Connection_Attributes) String() string { return proto.CompactTextString(m) }
func (*Connection_Attributes) ProtoMessage()    {}
func (*Connection_Attributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{9, 1}
}
func (m *Connection_Attributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection_Attributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection_Attributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection_Attributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection_Attributes.Merge(m, src)
}
func (m *Connection_Attributes) XXX_Size() int {
	return m.Size()
}
func (m *Connection_Attributes) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection_Attributes.DiscardUnknown(m)
}

var xxx_messageInfo_Connection_Attributes proto.InternalMessageInfo

func (m *Connection_Attributes) GetMultiplexer() string {
	if m != nil {
		return m.Multiplexer
	}
	return ""
}

func (m *Connection_Attributes) GetEncryption() string {
	if m != nil {
		return m.Encryption
	}
	return ""
}

// Stream reports metrics and state of a libp2p stream.
type Stream struct {
	// the id of this stream, not to be shown in user tooling,
	// used for (cross)referencing streams.
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the protocol pinned to this stream.
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// our role in this stream.
	Role Role `protobuf:"varint,3,opt,name=role,proto3,enum=introspection.Role" json:"role,omitempty"`
	// traffic statistics.
	Traffic *Traffic `protobuf:"bytes,4,opt,name=traffic,proto3" json:"traffic,omitempty"`
	// the connection this stream is hosted under.
	Conn *Stream_ConnectionRef `protobuf:"bytes,5,opt,name=conn,proto3" json:"conn,omitempty"`
	// the timeline of the stream, see Stream.Timeline.
	Timeline *Stream_Timeline `protobuf:"bytes,6,opt,name=timeline,proto3" json:"timeline,omitempty"`
	// the status of this stream.
	Status Status `protobuf:"varint,7,opt,name=status,proto3,enum=introspection.Status" json:"status,omitempty"`
	// the instantaneous latency of this stream in nanoseconds.
	// TODO: this is hard to calculate.
	LatencyNs uint64 `protobuf:"varint,16,opt,name=latency_ns,json=latencyNs,proto3" json:"latency_ns,omitempty"`
	// user provided tags.
	UserProvidedTags []string `protobuf:"bytes,99,rep,name=user_provided_tags,json=userProvidedTags,proto3" json:"user_provided_tags,omitempty"`
}

func (m *Stream) Reset()         { *m = Stream{} }
func (m *Stream) String() string { return proto.CompactTextString(m) }
func (*Stream) ProtoMessage()    {}
func (*Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{10}
}
func (m *Stream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream.Merge(m, src)
}
func (m *Stream) XXX_Size() int {
	return m.Size()
}
func (m *Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_Stream proto.InternalMessageInfo

func (m *Stream) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Stream) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Stream) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_INITIATOR
}

func (m *Stream) GetTraffic() *Traffic {
	if m != nil {
		return m.Traffic
	}
	return nil
}

func (m *Stream) GetConn() *Stream_ConnectionRef {
	if m != nil {
		return m.Conn
	}
	return nil
}

func (m *Stream) GetTimeline() *Stream_Timeline {
	if m != nil {
		return m.Timeline
	}
	return nil
}

func (m *Stream) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_ACTIVE
}

func (m *Stream) GetLatencyNs() uint64 {
	if m != nil {
		return m.LatencyNs
	}
	return 0
}

func (m *Stream) GetUserProvidedTags() []string {
	if m != nil {
		return m.UserProvidedTags
	}
	return nil
}

type Stream_ConnectionRef struct {
	// Types that are valid to be assigned to Connection:
	//	*Stream_ConnectionRef_Conn
	//	*Stream_ConnectionRef_ConnId
	Connection isStream_ConnectionRef_Connection `protobuf_oneof:"connection"`
}

func (m *Stream_ConnectionRef) Reset()         { *m = Stream_ConnectionRef{} }
func (m *Stream_ConnectionRef) String() string { return proto.CompactTextString(m) }
func (*Stream_ConnectionRef) ProtoMessage()    {}
func (*Stream_ConnectionRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{10, 0}
}
func (m *Stream_ConnectionRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream_ConnectionRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream_ConnectionRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream_ConnectionRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream_ConnectionRef.Merge(m, src)
}
func (m *Stream_ConnectionRef) XXX_Size() int {
	return m.Size()
}
func (m *Stream_ConnectionRef) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream_ConnectionRef.DiscardUnknown(m)
}

var xxx_messageInfo_Stream_ConnectionRef proto.InternalMessageInfo

type isStream_ConnectionRef_Connection interface {
	isStream_ConnectionRef_Connection()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Stream_ConnectionRef_Conn struct {
	Conn *Connection `protobuf:"bytes,1,opt,name=conn,proto3,oneof" json:"conn,omitempty"`
}
type Stream_ConnectionRef_ConnId struct {
	ConnId []byte `protobuf:"bytes,2,opt,name=conn_id,json=connId,proto3,oneof" json:"conn_id,omitempty"`
}

func (*Stream_ConnectionRef_Conn) isStream_ConnectionRef_Connection()   {}
func (*Stream_ConnectionRef_ConnId) isStream_ConnectionRef_Connection() {}

func (m *Stream_ConnectionRef) GetConnection() isStream_ConnectionRef_Connection {
	if m != nil {
		return m.Connection
	}
	return nil
}

func (m *Stream_ConnectionRef) GetConn() *Connection {
	if x, ok := m.GetConnection().(*Stream_ConnectionRef_Conn); ok {
		return x.Conn
	}
	return nil
}

func (m *Stream_ConnectionRef) GetConnId() []byte {
	if x, ok := m.GetConnection().(*Stream_ConnectionRef_ConnId); ok {
		return x.ConnId
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Stream_ConnectionRef) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Stream_ConnectionRef_Conn)(nil),
		(*Stream_ConnectionRef_ConnId)(nil),
	}
}

// Timeline contains the timestamps (ms since epoch) of the well-known milestones of a stream.
type Stream_Timeline struct {
	// the instant when the stream was opened.
	OpenTs uint64 `protobuf:"varint,1,opt,name=open_ts,json=openTs,proto3" json:"open_ts,omitempty"`
	// the instant when the stream was terminated.
	CloseTs uint64 `protobuf:"varint,2,opt,name=close_ts,json=closeTs,proto3" json:"close_ts,omitempty"`
}

func (m *Stream_Timeline) Reset()         { *m = Stream_Timeline{} }
func (m *Stream_Timeline) String() string { return proto.CompactTextString(m) }
func (*Stream_Timeline) ProtoMessage()    {}
func (*Stream_Timeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{10, 1}
}
func (m *Stream_Timeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream_Timeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream_Timeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream_Timeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream_Timeline.Merge(m, src)
}
func (m *Stream_Timeline) XXX_Size() int {
	return m.Size()
}
func (m *Stream_Timeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream_Timeline.DiscardUnknown(m)
}

var xxx_messageInfo_Stream_Timeline proto.InternalMessageInfo

func (m *Stream_Timeline) GetOpenTs() uint64 {
	if m != nil {
		return m.OpenTs
	}
	return 0
}

func (m *Stream_Timeline) GetCloseTs() uint64 {
	if m != nil {
		return m.CloseTs
	}
	return 0
}

// DHT metrics and state.
type DHT struct {
	// DHT protocol name
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// protocol enabled.
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// timestamp (ms since epoch) of start up.
	StartTs uint64 `protobuf:"varint,3,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	// params of the dht.
	Params *DHT_Params `protobuf:"bytes,4,opt,name=params,proto3" json:"params,omitempty"`
	// existing, intantiated buckets and their contents
	Buckets []*DHT_Bucket `protobuf:"bytes,5,rep,name=buckets,proto3" json:"buckets,omitempty"`
	// counts inbound queries received from other peers
	IncomingQueries *DHT_QueryGauge `protobuf:"bytes,6,opt,name=incoming_queries,json=incomingQueries,proto3" json:"incoming_queries,omitempty"`
	// counts outbound queries dispatched by this peer
	OutgoingQueries *DHT_QueryGauge `protobuf:"bytes,7,opt,name=outgoing_queries,json=outgoingQueries,proto3" json:"outgoing_queries,omitempty"`
}

func (m *DHT) Reset()         { *m = DHT{} }
func (m *DHT) String() string { return proto.CompactTextString(m) }
func (*DHT) ProtoMessage()    {}
func (*DHT) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{11}
}
func (m *DHT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHT.Merge(m, src)
}
func (m *DHT) XXX_Size() int {
	return m.Size()
}
func (m *DHT) XXX_DiscardUnknown() {
	xxx_messageInfo_DHT.DiscardUnknown(m)
}

var xxx_messageInfo_DHT proto.InternalMessageInfo

func (m *DHT) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *DHT) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *DHT) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *DHT) GetParams() *DHT_Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *DHT) GetBuckets() []*DHT_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func (m *DHT) GetIncomingQueries() *DHT_QueryGauge {
	if m != nil {
		return m.IncomingQueries
	}
	return nil
}

func (m *DHT) GetOutgoingQueries() *DHT_QueryGauge {
	if m != nil {
		return m.OutgoingQueries
	}
	return nil
}

type DHT_Params struct {
	// routing table bucket size.
	K uint64 `protobuf:"varint,1,opt,name=k,proto3" json:"k,omitempty"`
	// concurrency of asynchronous requests.
	Alpha uint64 `protobuf:"varint,2,opt,name=alpha,proto3" json:"alpha,omitempty"`
	// number of disjoint paths to use.
	DisjointPaths uint64 `protobuf:"varint,3,opt,name=disjoint_paths,json=disjointPaths,proto3" json:"disjoint_paths,omitempty"`
	// number of peers closest to a target that must have responded
	// in order for a given query path to complete
	Beta uint64 `protobuf:"varint,4,opt,name=beta,proto3" json:"beta,omitempty"`
}

func (m *DHT_Params) Reset()         { *m = DHT_Params{} }
func (m *DHT_Params) String() string { return proto.CompactTextString(m) }
func (*DHT_Params) ProtoMessage()    {}
func (*DHT_Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{11, 0}
}
func (m *DHT_Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHT_Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHT_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHT_Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHT_Params.Merge(m, src)
}
func (m *DHT_Params) XXX_Size() int {
	return m.Size()
}
func (m *DHT_Params) XXX_DiscardUnknown() {
	xxx_messageInfo_DHT_Params.DiscardUnknown(m)
}

var xxx_messageInfo_DHT_Params proto.InternalMessageInfo

func (m *DHT_Params) GetK() uint64 {
	if m != nil {
		return m.K
	}
	return 0
}

func (m *DHT_Params) GetAlpha() uint64 {
	if m != nil {
		return m.Alpha
	}
	return 0
}

func (m *DHT_Params) GetDisjointPaths() uint64 {
	if m != nil {
		return m.DisjointPaths
	}
	return 0
}

func (m *DHT_Params) GetBeta() uint64 {
	if m != nil {
		return m.Beta
	}
	return 0
}

// Peer in DHT
type DHT_PeerInDHT struct {
	// the peer id of the host system
	PeerId string `protobuf:"bytes,1,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	// the peer's status when data snapshot is taken
	Status DHT_PeerInDHT_Status `protobuf:"varint,2,opt,name=status,proto3,enum=introspection.DHT_PeerInDHT_Status" json:"status,omitempty"`
	// age in bucket (ms)
	AgeInBucket uint32 `protobuf:"varint,3,opt,name=age_in_bucket,json=ageInBucket,proto3" json:"age_in_bucket,omitempty"`
}

func (m *DHT_PeerInDHT) Reset()         { *m = DHT_PeerInDHT{} }
func (m *DHT_PeerInDHT) String() string { return proto.CompactTextString(m) }
func (*DHT_PeerInDHT) ProtoMessage()    {}
func (*DHT_PeerInDHT) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{11, 1}
}
func (m *DHT_PeerInDHT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHT_PeerInDHT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHT_PeerInDHT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHT_PeerInDHT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHT_PeerInDHT.Merge(m, src)
}
func (m *DHT_PeerInDHT) XXX_Size() int {
	return m.Size()
}
func (m *DHT_PeerInDHT) XXX_DiscardUnknown() {
	xxx_messageInfo_DHT_PeerInDHT.DiscardUnknown(m)
}

var xxx_messageInfo_DHT_PeerInDHT proto.InternalMessageInfo

func (m *DHT_PeerInDHT) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *DHT_PeerInDHT) GetStatus() DHT_PeerInDHT_Status {
	if m != nil {
		return m.Status
	}
	return DHT_PeerInDHT_ACTIVE
}

func (m *DHT_PeerInDHT) GetAgeInBucket() uint32 {
	if m != nil {
		return m.AgeInBucket
	}
	return 0
}

// A "k-bucket" containing peers of a certain kadamelia distance
type DHT_Bucket struct {
	// CPL (Common Prefix Length) is the length of the common prefix
	// between the ids of every peer in this bucket and the DHT peer id
	Cpl uint32 `protobuf:"varint,1,opt,name=cpl,proto3" json:"cpl,omitempty"`
	// Peers associated with this bucket
	Peers []*DHT_PeerInDHT `protobuf:"bytes,2,rep,name=peers,proto3" json:"peers,omitempty"`
}

func (m *DHT_Bucket) Reset()         { *m = DHT_Bucket{} }
func (m *DHT_Bucket) String() string { return proto.CompactTextString(m) }
func (*DHT_Bucket) ProtoMessage()    {}
func (*DHT_Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{11, 2}
}
func (m *DHT_Bucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHT_Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHT_Bucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHT_Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHT_Bucket.Merge(m, src)
}
func (m *DHT_Bucket) XXX_Size() int {
	return m.Size()
}
func (m *DHT_Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_DHT_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_DHT_Bucket proto.InternalMessageInfo

func (m *DHT_Bucket) GetCpl() uint32 {
	if m != nil {
		return m.Cpl
	}
	return 0
}

func (m *DHT_Bucket) GetPeers() []*DHT_PeerInDHT {
	if m != nil {
		return m.Peers
	}
	return nil
}

// Counters of query events, by status
type DHT_QueryGauge struct {
	// Cumulative counter of queries with "SUCCESS" status
	Success uint64 `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Cumulative counter of queries with "ERROR" status
	Error uint64 `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
	// Cumulative counter of queries with "TIMEOUT" status
	Timeout uint64 `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *DHT_QueryGauge) Reset()         { *m = DHT_QueryGauge{} }
func (m *DHT_QueryGauge) String() string { return proto.CompactTextString(m) }
func (*DHT_QueryGauge) ProtoMessage()    {}
func (*DHT_QueryGauge) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{11, 3}
}
func (m *DHT_QueryGauge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHT_QueryGauge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DHT_QueryGauge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DHT_QueryGauge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHT_QueryGauge.Merge(m, src)
}
func (m *DHT_QueryGauge) XXX_Size() int {
	return m.Size()
}
func (m *DHT_QueryGauge) XXX_DiscardUnknown() {
	xxx_messageInfo_DHT_QueryGauge.DiscardUnknown(m)
}

var xxx_messageInfo_DHT_QueryGauge proto.InternalMessageInfo

func (m *DHT_QueryGauge) GetSuccess() uint64 {
	if m != nil {
		return m.Success
	}
	return 0
}

func (m *DHT_QueryGauge) GetError() uint64 {
	if m != nil {
		return m.Error
	}
	return 0
}

func (m *DHT_QueryGauge) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// Subsystems encapsulates all instrumented subsystems for a libp2p host.
type Subsystems struct {
	// connections data, source agnostic but currently only supports the Swarm subsystem
	Connections []*Connection `protobuf:"bytes,1,rep,name=connections,proto3" json:"connections,omitempty"`
	// the DHT subsystem.
	Dht *DHT `protobuf:"bytes,2,opt,name=dht,proto3" json:"dht,omitempty"`
}

func (m *Subsystems) Reset()         { *m = Subsystems{} }
func (m *Subsystems) String() string { return proto.CompactTextString(m) }
func (*Subsystems) ProtoMessage()    {}
func (*Subsystems) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{12}
}
func (m *Subsystems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subsystems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subsystems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subsystems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subsystems.Merge(m, src)
}
func (m *Subsystems) XXX_Size() int {
	return m.Size()
}
func (m *Subsystems) XXX_DiscardUnknown() {
	xxx_messageInfo_Subsystems.DiscardUnknown(m)
}

var xxx_messageInfo_Subsystems proto.InternalMessageInfo

func (m *Subsystems) GetConnections() []*Connection {
	if m != nil {
		return m.Connections
	}
	return nil
}

func (m *Subsystems) GetDht() *DHT {
	if m != nil {
		return m.Dht
	}
	return nil
}

// Connections and streams output for a time interval is one of these.
type State struct {
	// list of connections
	Subsystems *Subsystems `protobuf:"bytes,1,opt,name=subsystems,proto3" json:"subsystems,omitempty"`
	// overall traffic for this peer
	Traffic *Traffic `protobuf:"bytes,2,opt,name=traffic,proto3" json:"traffic,omitempty"`
	// moment this data snapshot and instantaneous values were taken
	InstantTs uint64 `protobuf:"varint,3,opt,name=instant_ts,json=instantTs,proto3" json:"instant_ts,omitempty"`
	// start of included data collection (cumulative values counted from here)
	StartTs uint64 `protobuf:"varint,4,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	// length of time up to instant_ts covered by this data snapshot
	SnapshotDurationMs uint32 `protobuf:"varint,5,opt,name=snapshot_duration_ms,json=snapshotDurationMs,proto3" json:"snapshot_duration_ms,omitempty"`
}

func (m *State) Reset()         { *m = State{} }
func (m *State) String() string { return proto.CompactTextString(m) }
func (*State) ProtoMessage()    {}
func (*State) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{13}
}
func (m *State) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *State) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_State.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *State) XXX_Merge(src proto.Message) {
	xxx_messageInfo_State.Merge(m, src)
}
func (m *State) XXX_Size() int {
	return m.Size()
}
func (m *State) XXX_DiscardUnknown() {
	xxx_messageInfo_State.DiscardUnknown(m)
}

var xxx_messageInfo_State proto.InternalMessageInfo

func (m *State) GetSubsystems() *Subsystems {
	if m != nil {
		return m.Subsystems
	}
	return nil
}

func (m *State) GetTraffic() *Traffic {
	if m != nil {
		return m.Traffic
	}
	return nil
}

func (m *State) GetInstantTs() uint64 {
	if m != nil {
		return m.InstantTs
	}
	return 0
}

func (m *State) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *State) GetSnapshotDurationMs() uint32 {
	if m != nil {
		return m.SnapshotDurationMs
	}
	return 0
}

// Event
type Event struct {
	// definition of event type, containing only `name` unless this is first encounter of novel event
	Type *EventType `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// time this event occurred (ms since epoch)
	Ts uint64 `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	// stringified json; top-level keys and value types match EventProperty definitions
	Content string `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{14}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetType() *EventType {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Event) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *Event) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// ProtocolDataPacket wraps messages to be sent to clients to allow extension
// based on new types of data sources
type ProtocolDataPacket struct {
	// Version of this protobuf
	Version *Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// The Message this contains
	//
	// Types that are valid to be assigned to Message:
	//	*ProtocolDataPacket_State
	//	*ProtocolDataPacket_Runtime
	//	*ProtocolDataPacket_Event
	Message isProtocolDataPacket_Message `protobuf_oneof:"message"`
}

func (m *ProtocolDataPacket) Reset()         { *m = ProtocolDataPacket{} }
func (m *ProtocolDataPacket) String() string { return proto.CompactTextString(m) }
func (*ProtocolDataPacket) ProtoMessage()    {}
func (*ProtocolDataPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{15}
}
func (m *ProtocolDataPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolDataPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolDataPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolDataPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolDataPacket.Merge(m, src)
}
func (m *ProtocolDataPacket) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolDataPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolDataPacket.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolDataPacket proto.InternalMessageInfo

type isProtocolDataPacket_Message interface {
	isProtocolDataPacket_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProtocolDataPacket_State struct {
	State *State `protobuf:"bytes,2,opt,name=state,proto3,oneof" json:"state,omitempty"`
}
type ProtocolDataPacket_Runtime struct {
	Runtime *Runtime `protobuf:"bytes,3,opt,name=runtime,proto3,oneof" json:"runtime,omitempty"`
}
type ProtocolDataPacket_Event struct {
	Event *Event `protobuf:"bytes,4,opt,name=event,proto3,oneof" json:"event,omitempty"`
}

func (*ProtocolDataPacket_State) isProtocolDataPacket_Message()   {}
func (*ProtocolDataPacket_Runtime) isProtocolDataPacket_Message() {}
func (*ProtocolDataPacket_Event) isProtocolDataPacket_Message()   {}

func (m *ProtocolDataPacket) GetMessage() isProtocolDataPacket_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ProtocolDataPacket) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ProtocolDataPacket) GetState() *State {
	if x, ok := m.GetMessage().(*ProtocolDataPacket_State); ok {
		return x.State
	}
	return nil
}

func (m *ProtocolDataPacket) GetRuntime() *Runtime {
	if x, ok := m.GetMessage().(*ProtocolDataPacket_Runtime); ok {
		return x.Runtime
	}
	return nil
}

func (m *ProtocolDataPacket) GetEvent() *Event {
	if x, ok := m.GetMessage().(*ProtocolDataPacket_Event); ok {
		return x.Event
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProtocolDataPacket) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProtocolDataPacket_State)(nil),
		(*ProtocolDataPacket_Runtime)(nil),
		(*ProtocolDataPacket_Event)(nil),
	}
}

// ClientSignal is a type of message to be sent from clients to the server to signal
// within the operation of the protocol
type ClientSignal struct {
	// Version of this protobuf
	Version *Version `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Signal to be sent
	Signal ClientSignal_Signal `protobuf:"varint,2,opt,name=signal,proto3,enum=introspection.ClientSignal_Signal" json:"signal,omitempty"`
	// Correlated DataSource for this signal (if any)
	DataSource ClientSignal_DataSource `protobuf:"varint,3,opt,name=data_source,json=dataSource,proto3,enum=introspection.ClientSignal_DataSource" json:"data_source,omitempty"`
	// Optional: JSON stringified content to be sent to the emitter
	Content string `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *ClientSignal) Reset()         { *m = ClientSignal{} }
func (m *ClientSignal) String() string { return proto.CompactTextString(m) }
func (*ClientSignal) ProtoMessage()    {}
func (*ClientSignal) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a8bedf9a75e10a, []int{16}
}
func (m *ClientSignal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientSignal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientSignal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientSignal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientSignal.Merge(m, src)
}
func (m *ClientSignal) XXX_Size() int {
	return m.Size()
}
func (m *ClientSignal) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientSignal.DiscardUnknown(m)
}

var xxx_messageInfo_ClientSignal proto.InternalMessageInfo

func (m *ClientSignal) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ClientSignal) GetSignal() ClientSignal_Signal {
	if m != nil {
		return m.Signal
	}
	return ClientSignal_SEND_DATA
}

func (m *ClientSignal) GetDataSource() ClientSignal_DataSource {
	if m != nil {
		return m.DataSource
	}
	return ClientSignal_STATE
}

func (m *ClientSignal) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func init() {
	proto.RegisterEnum("introspection.Status", Status_name, Status_value)
	proto.RegisterEnum("introspection.Role", Role_name, Role_value)
	proto.RegisterEnum("introspection.EventType_EventProperty_PropertyType", EventType_EventProperty_PropertyType_name, EventType_EventProperty_PropertyType_value)
	proto.RegisterEnum("introspection.DHT_PeerInDHT_Status", DHT_PeerInDHT_Status_name, DHT_PeerInDHT_Status_value)
	proto.RegisterEnum("introspection.ClientSignal_Signal", ClientSignal_Signal_name, ClientSignal_Signal_value)
	proto.RegisterEnum("introspection.ClientSignal_DataSource", ClientSignal_DataSource_name, ClientSignal_DataSource_value)
	proto.RegisterType((*Version)(nil), "introspection.Version")
	proto.RegisterType((*ResultCounter)(nil), "introspection.ResultCounter")
	proto.RegisterType((*SlidingCounter)(nil), "introspection.SlidingCounter")
	proto.RegisterType((*DataGauge)(nil), "introspection.DataGauge")
	proto.RegisterType((*EventType)(nil), "introspection.EventType")
	proto.RegisterType((*EventType_EventProperty)(nil), "introspection.EventType.EventProperty")
	proto.RegisterType((*Runtime)(nil), "introspection.Runtime")
	proto.RegisterType((*EndpointPair)(nil), "introspection.EndpointPair")
	proto.RegisterType((*Traffic)(nil), "introspection.Traffic")
	proto.RegisterType((*StreamList)(nil), "introspection.StreamList")
	proto.RegisterType((*Connection)(nil), "introspection.Connection")
	proto.RegisterType((*Connection_Timeline)(nil), "introspection.Connection.Timeline")
	proto.RegisterType((*Connection_Attributes)(nil), "introspection.Connection.Attributes")
	proto.RegisterType((*Stream)(nil), "introspection.Stream")
	proto.RegisterType((*Stream_ConnectionRef)(nil), "introspection.Stream.ConnectionRef")
	proto.RegisterType((*Stream_Timeline)(nil), "introspection.Stream.Timeline")
	proto.RegisterType((*DHT)(nil), "introspection.DHT")
	proto.RegisterType((*DHT_Params)(nil), "introspection.DHT.Params")
	proto.RegisterType((*DHT_PeerInDHT)(nil), "introspection.DHT.PeerInDHT")
	proto.RegisterType((*DHT_Bucket)(nil), "introspection.DHT.Bucket")
	proto.RegisterType((*DHT_QueryGauge)(nil), "introspection.DHT.QueryGauge")
	proto.RegisterType((*Subsystems)(nil), "introspection.Subsystems")
	proto.RegisterType((*State)(nil), "introspection.State")
	proto.RegisterType((*Event)(nil), "introspection.Event")
	proto.RegisterType((*ProtocolDataPacket)(nil), "introspection.ProtocolDataPacket")
	proto.RegisterType((*ClientSignal)(nil), "introspection.ClientSignal")
}

func init() { proto.RegisterFile("introspection.proto", fileDescriptor_53a8bedf9a75e10a) }

var fileDescriptor_53a8bedf9a75e10a = []byte{
	// 2012 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x5f, 0x6f, 0xdb, 0xc8,
	0x11, 0xd7, 0x3f, 0xeb, 0xcf, 0xe8, 0xcf, 0xa9, 0x7b, 0x69, 0xaa, 0xf8, 0x1a, 0x37, 0x65, 0xd2,
	0x34, 0xb8, 0xa6, 0xbe, 0x44, 0xb9, 0xe0, 0x2e, 0x77, 0x40, 0x00, 0xdb, 0x52, 0x6d, 0x05, 0x91,
	0xac, 0x5b, 0xd1, 0x41, 0x51, 0xb4, 0x20, 0x68, 0x72, 0x23, 0xb1, 0xa6, 0x48, 0x76, 0x77, 0xe9,
	0xab, 0x1f, 0xfa, 0x1d, 0xfa, 0x05, 0xda, 0x2f, 0x70, 0x6f, 0xfd, 0x0e, 0x05, 0xfa, 0x78, 0x6f,
	0xed, 0xe3, 0x35, 0x29, 0xfa, 0x39, 0x8a, 0x59, 0x2e, 0x29, 0xca, 0x56, 0x02, 0x5f, 0x9f, 0xb4,
	0x33, 0xf3, 0x9b, 0x59, 0xee, 0xce, 0x9f, 0x9d, 0x11, 0x7c, 0xe8, 0x05, 0x92, 0x87, 0x22, 0x62,
	0x8e, 0xf4, 0xc2, 0x60, 0x37, 0xe2, 0xa1, 0x0c, 0x49, 0x7b, 0x8d, 0x69, 0xdc, 0x85, 0xda, 0x2b,
	0xc6, 0x85, 0x17, 0x06, 0xa4, 0x07, 0xb5, 0xf3, 0x64, 0xd9, 0x2b, 0xde, 0x29, 0x3e, 0x68, 0xd3,
	0x94, 0x34, 0x0e, 0xa1, 0x4d, 0x99, 0x88, 0x7d, 0x79, 0x10, 0xc6, 0x81, 0x64, 0x9c, 0xdc, 0x80,
	0x2d, 0x19, 0x4a, 0xdb, 0xd7, 0xc0, 0x84, 0x20, 0x1d, 0x28, 0x85, 0x67, 0xbd, 0x92, 0x62, 0x95,
	0xc2, 0x33, 0xd2, 0x85, 0x32, 0xe3, 0xbc, 0x57, 0x56, 0x0c, 0x5c, 0x1a, 0x7f, 0x2d, 0x41, 0x67,
	0xe6, 0x7b, 0xae, 0x17, 0xcc, 0x53, 0x53, 0x3f, 0x82, 0x5a, 0x78, 0xce, 0xb8, 0xf5, 0x78, 0xa9,
	0x8d, 0x55, 0x91, 0x7c, 0xbc, 0xcc, 0x04, 0x4f, 0x97, 0xda, 0xa4, 0x12, 0x3c, 0x5d, 0x92, 0x5b,
	0x50, 0x4f, 0x34, 0x9e, 0x2e, 0xb5, 0x6d, 0x05, 0x7c, 0x9c, 0x13, 0x3d, 0x79, 0xb4, 0xec, 0x55,
	0x56, 0xa2, 0x27, 0x8f, 0x72, 0x5a, 0x0b, 0xde, 0xdb, 0xca, 0x69, 0x2d, 0x78, 0x26, 0xea, 0x2f,
	0x78, 0xaf, 0xba, 0x12, 0xf5, 0x73, 0xa2, 0x4f, 0x17, 0xbc, 0x57, 0x5b, 0x89, 0x3e, 0xcd, 0x89,
	0x3e, 0x5f, 0xf0, 0x5e, 0x7d, 0x25, 0xfa, 0x7c, 0xc1, 0xc9, 0x47, 0xd0, 0x48, 0xf6, 0x42, 0x8b,
	0x0d, 0x25, 0x53, 0x58, 0xa4, 0x33, 0x61, 0x1f, 0x6d, 0xc2, 0x4a, 0x88, 0xb4, 0x71, 0x0a, 0x8d,
	0x81, 0x2d, 0xed, 0x43, 0x3b, 0x9e, 0x33, 0x44, 0x3a, 0xf1, 0xd2, 0x3a, 0xbd, 0x90, 0x4c, 0xa8,
	0xcb, 0xa9, 0xd0, 0xba, 0x13, 0x2f, 0xf7, 0x91, 0x26, 0x3f, 0x81, 0x26, 0x0a, 0x23, 0xdb, 0x39,
	0x63, 0x52, 0xa8, 0x2b, 0xaa, 0x50, 0x70, 0xe2, 0xe5, 0x34, 0xe1, 0xe0, 0xfd, 0x79, 0x81, 0x90,
	0xd6, 0xe9, 0xd7, 0xea, 0x96, 0x2a, 0xb4, 0x8a, 0xe4, 0xfe, 0xd7, 0xc6, 0x3f, 0x4b, 0xd0, 0x18,
	0x9e, 0xb3, 0x40, 0x9a, 0x17, 0x11, 0x23, 0x04, 0x2a, 0x81, 0xbd, 0x64, 0xca, 0x7e, 0x83, 0xaa,
	0x35, 0x19, 0x43, 0x27, 0xe2, 0x61, 0xc4, 0xb8, 0xbc, 0xb0, 0xe4, 0x45, 0xc4, 0xd0, 0x7c, 0xf9,
	0x41, 0xb3, 0x7f, 0x7f, 0x77, 0x3d, 0xa2, 0x32, 0x2b, 0xc9, 0x6a, 0xaa, 0x75, 0x68, 0x3b, 0xd5,
	0x46, 0x99, 0xd8, 0xfe, 0x6f, 0x11, 0xda, 0x6b, 0x80, 0x8d, 0x9b, 0x1e, 0x42, 0x05, 0xf7, 0x52,
	0x27, 0xe9, 0xf4, 0x9f, 0x5c, 0x6f, 0xab, 0xdd, 0x69, 0x6e, 0x27, 0xaa, 0x0c, 0x90, 0x9f, 0x42,
	0x6b, 0x61, 0x0b, 0x6b, 0x19, 0xfb, 0xd2, 0x8b, 0x7c, 0xa6, 0x4e, 0x5f, 0xa7, 0xcd, 0x85, 0x2d,
	0xc6, 0x9a, 0x65, 0x9c, 0x40, 0x2b, 0xaf, 0x48, 0x00, 0xaa, 0x33, 0x93, 0x8e, 0x26, 0x87, 0xdd,
	0x02, 0xae, 0x27, 0x27, 0xe3, 0xfd, 0x21, 0xed, 0x16, 0x49, 0x1d, 0x2a, 0xe6, 0x68, 0x3c, 0xec,
	0x02, 0x72, 0xa7, 0xc3, 0x21, 0x1d, 0x0d, 0xba, 0x4d, 0xd2, 0x86, 0xc6, 0xf8, 0xe4, 0xa5, 0x39,
	0xda, 0x1b, 0x0c, 0x68, 0xb7, 0x85, 0xa0, 0x17, 0xb3, 0xe3, 0x49, 0xf7, 0x37, 0xc6, 0x5f, 0x4a,
	0x50, 0xa3, 0x71, 0x20, 0xbd, 0x25, 0x23, 0xf7, 0xa1, 0xe3, 0x2d, 0x23, 0x9f, 0x2d, 0x59, 0x20,
	0x6d, 0x99, 0x26, 0x55, 0x83, 0x5e, 0xe2, 0xe6, 0xb3, 0xae, 0xa4, 0x00, 0x29, 0x49, 0xb6, 0xa1,
	0x1e, 0xf9, 0xb6, 0x7c, 0x1d, 0xf2, 0x24, 0xce, 0x1b, 0x34, 0xa3, 0xd1, 0xb9, 0x11, 0x63, 0xdc,
	0xf2, 0x5c, 0x15, 0xe7, 0x0d, 0x5a, 0x45, 0x72, 0xe4, 0x92, 0x5f, 0x00, 0x39, 0x63, 0x2c, 0xb2,
	0x84, 0xb4, 0x7d, 0x66, 0xb9, 0xb6, 0xb4, 0xad, 0xa5, 0xd0, 0x01, 0xff, 0x01, 0x4a, 0x66, 0x28,
	0xc0, 0x18, 0x1b, 0x0b, 0xf2, 0x04, 0x6e, 0x0a, 0x16, 0xb8, 0x08, 0x96, 0xcc, 0xf2, 0x30, 0x1f,
	0xcf, 0x6d, 0x1f, 0x15, 0x92, 0x34, 0xf8, 0x10, 0xa5, 0x33, 0x14, 0x8e, 0xb4, 0x6c, 0x2c, 0xc8,
	0x33, 0x68, 0x32, 0x74, 0x81, 0x8e, 0x8c, 0x9a, 0x8a, 0x8c, 0xde, 0xbb, 0xdc, 0x45, 0x81, 0xa5,
	0x4b, 0x61, 0xfc, 0x1a, 0x5a, 0xc3, 0xc0, 0x8d, 0x42, 0x2f, 0x90, 0x53, 0xdb, 0xe3, 0xe4, 0x2e,
	0xb4, 0x05, 0x77, 0x12, 0x4f, 0xd9, 0xae, 0xcb, 0xf5, 0x15, 0xb5, 0x04, 0x77, 0xc6, 0x29, 0x0f,
	0x41, 0xae, 0x90, 0x39, 0x50, 0x72, 0x4d, 0x2d, 0x57, 0xc8, 0x0c, 0x64, 0xfc, 0x09, 0x6a, 0x26,
	0xb7, 0x5f, 0xbf, 0xf6, 0x1c, 0xf2, 0x19, 0x80, 0x4c, 0x96, 0x96, 0x97, 0x5c, 0xfa, 0xd5, 0xcf,
	0xcb, 0x72, 0x8c, 0x36, 0x34, 0x76, 0x14, 0xe0, 0xc1, 0x52, 0xc5, 0x30, 0x96, 0x6a, 0x9b, 0xf7,
	0x69, 0xa6, 0xbb, 0x1c, 0xc7, 0xd2, 0xf8, 0x2d, 0xc0, 0x4c, 0x72, 0x66, 0x2f, 0x5f, 0x7a, 0x42,
	0x92, 0xdb, 0x00, 0x42, 0x51, 0x96, 0xe7, 0x62, 0xe2, 0x96, 0x1f, 0xb4, 0x68, 0x23, 0xe1, 0x8c,
	0x5c, 0x41, 0x3e, 0x81, 0x5a, 0x42, 0xa4, 0x69, 0xf5, 0xc3, 0x4b, 0x7b, 0x24, 0xa6, 0x68, 0x8a,
	0x32, 0xfe, 0x56, 0x05, 0x38, 0x08, 0x83, 0x20, 0x11, 0x63, 0x99, 0xf5, 0x5c, 0x75, 0xb0, 0x16,
	0x2d, 0x79, 0x6e, 0x3e, 0x16, 0x4a, 0x6b, 0xb1, 0xf0, 0x4b, 0xa8, 0xa2, 0x67, 0x63, 0xa1, 0xc2,
	0xa7, 0xb3, 0x61, 0x1f, 0x14, 0x52, 0x0d, 0xc2, 0xbc, 0x91, 0xdc, 0x0e, 0x44, 0x14, 0x72, 0x99,
	0x06, 0x56, 0x8b, 0x36, 0x33, 0xde, 0xc8, 0x25, 0xcf, 0xa0, 0xc1, 0xb4, 0x03, 0x93, 0xa0, 0x6a,
	0xf6, 0x3f, 0xba, 0xec, 0xf9, 0x9c, 0x83, 0xe9, 0x0a, 0x4d, 0x9e, 0x43, 0x1d, 0xf3, 0xc2, 0xf7,
	0x02, 0xa6, 0xa2, 0xab, 0xd9, 0x37, 0x2e, 0x69, 0xae, 0x8e, 0xb8, 0x6b, 0x6a, 0x24, 0xcd, 0x74,
	0xc8, 0xcf, 0xa1, 0xc2, 0x43, 0x9f, 0xa9, 0x2a, 0xdc, 0xe9, 0x7f, 0x78, 0x49, 0x97, 0x86, 0x3e,
	0xa3, 0x0a, 0x40, 0x1e, 0x41, 0x4d, 0x7b, 0x46, 0x95, 0xe5, 0x66, 0xff, 0xe6, 0x25, 0xac, 0x0e,
	0x14, 0x9a, 0xc2, 0xc8, 0x73, 0xa8, 0xd9, 0x52, 0x72, 0xef, 0x54, 0xa8, 0x62, 0xdd, 0xec, 0xdf,
	0x7b, 0xf7, 0x97, 0xed, 0x29, 0x60, 0x2c, 0x99, 0xa0, 0xa9, 0x12, 0xfa, 0xdb, 0xb7, 0x25, 0x0b,
	0x9c, 0x0b, 0x2b, 0x10, 0xaa, 0xa4, 0x57, 0x68, 0x43, 0x73, 0x26, 0x98, 0x65, 0x99, 0xbf, 0x9b,
	0xca, 0xfc, 0xad, 0x8d, 0xfe, 0xc6, 0xd0, 0xc9, 0x7c, 0x4e, 0x6e, 0x41, 0xcd, 0x09, 0x83, 0x00,
	0xfd, 0xd0, 0x45, 0x3f, 0x1c, 0x15, 0x68, 0x15, 0x19, 0x23, 0x97, 0x7c, 0x02, 0x15, 0x5c, 0xf5,
	0x7e, 0xb0, 0xd1, 0xd8, 0xea, 0x5b, 0x8f, 0x0a, 0x54, 0x01, 0xc9, 0x43, 0x20, 0xb1, 0x60, 0xdc,
	0x8a, 0x78, 0x78, 0xee, 0xb9, 0xcc, 0xb5, 0xa4, 0x3d, 0x17, 0x3d, 0xe7, 0x4e, 0xf9, 0x41, 0x83,
	0x76, 0x51, 0x32, 0xd5, 0x02, 0xd3, 0x9e, 0x8b, 0x6d, 0x0b, 0xea, 0xe9, 0xf5, 0xab, 0x37, 0x38,
	0x62, 0x81, 0x25, 0xd3, 0xf7, 0xa7, 0x8a, 0xa4, 0xa9, 0x5e, 0x9f, 0x38, 0x9a, 0x73, 0x5b, 0x59,
	0xcb, 0x5e, 0x9f, 0x94, 0x65, 0xe2, 0xf7, 0xd7, 0x1d, 0x3f, 0x14, 0x0c, 0xa5, 0xc9, 0xf3, 0x53,
	0x53, 0xb4, 0x29, 0xb6, 0x27, 0x00, 0xab, 0x5b, 0x24, 0x77, 0xa0, 0x99, 0x56, 0xea, 0x3f, 0xb2,
	0xb4, 0x02, 0xe4, 0x59, 0x64, 0x07, 0x80, 0x05, 0x0e, 0xbf, 0x88, 0xe4, 0xaa, 0x48, 0xe6, 0x38,
	0xfb, 0x1d, 0x68, 0x71, 0xe6, 0xdb, 0x17, 0xcc, 0xb5, 0xf0, 0x1d, 0x7d, 0x51, 0xa9, 0xb7, 0xba,
	0x5d, 0xe3, 0x9b, 0x0a, 0x54, 0x93, 0x8b, 0xbd, 0x92, 0x30, 0x58, 0x58, 0xb1, 0x17, 0x72, 0x42,
	0x5f, 0x9b, 0xcb, 0xe8, 0x2c, 0xcc, 0xca, 0xdf, 0x23, 0xcc, 0x2a, 0xd7, 0x0b, 0xb3, 0xcf, 0xb4,
	0xdf, 0x92, 0xbc, 0xb9, 0xbb, 0x31, 0x08, 0x72, 0xee, 0xa3, 0xec, 0xb5, 0xf6, 0xdf, 0x17, 0x57,
	0x52, 0x67, 0x67, 0xb3, 0xf2, 0x86, 0xb4, 0x59, 0xd5, 0x80, 0xda, 0x75, 0x6a, 0xc0, 0x7a, 0x28,
	0x77, 0x2f, 0x87, 0xf2, 0xf7, 0x8b, 0x24, 0x0f, 0xda, 0x6b, 0xc7, 0xc9, 0x22, 0xb7, 0x78, 0xdd,
	0xc8, 0xcd, 0x65, 0x41, 0x69, 0x3d, 0x0b, 0xf6, 0x5b, 0x00, 0x4e, 0xa6, 0xb0, 0xfd, 0xfc, 0x3a,
	0x41, 0x9b, 0x8f, 0xc9, 0xd2, 0x5a, 0x4c, 0x1a, 0xdf, 0x54, 0xa1, 0x3c, 0x38, 0x32, 0xd7, 0x42,
	0xa3, 0x78, 0x29, 0x34, 0x7a, 0x50, 0x63, 0x81, 0x7d, 0xea, 0xb3, 0xe4, 0x63, 0xea, 0x34, 0x25,
	0xd1, 0xb0, 0x90, 0x36, 0x97, 0xb9, 0x60, 0x57, 0xb4, 0x29, 0xc8, 0x63, 0xa8, 0x46, 0x36, 0xc7,
	0xdc, 0xaf, 0x6c, 0x3c, 0xf4, 0xe0, 0xc8, 0xdc, 0x9d, 0x2a, 0x00, 0xd5, 0x40, 0xac, 0x17, 0xa7,
	0x71, 0xd2, 0xd5, 0x6d, 0xa9, 0xf7, 0x61, 0x93, 0xce, 0xbe, 0x42, 0xd0, 0x14, 0x49, 0x8e, 0xa0,
	0xeb, 0x05, 0x4e, 0xb8, 0xf4, 0x82, 0xb9, 0xf5, 0x87, 0x98, 0x71, 0x8f, 0x09, 0x1d, 0x2b, 0xb7,
	0x37, 0x68, 0x7f, 0x15, 0x33, 0x7e, 0x91, 0x3c, 0x63, 0x1f, 0xa4, 0x6a, 0x5f, 0x25, 0x5a, 0x68,
	0x29, 0x8c, 0xe5, 0x3c, 0xcc, 0x5b, 0xaa, 0x5d, 0xcb, 0x52, 0xaa, 0xa6, 0x2d, 0x6d, 0xcf, 0xa1,
	0x9a, 0x1c, 0x8d, 0xb4, 0xa0, 0x78, 0xa6, 0x9d, 0x51, 0x3c, 0xc3, 0xe9, 0xc1, 0xf6, 0xa3, 0x85,
	0xad, 0x9d, 0x90, 0x10, 0xe4, 0x67, 0xd0, 0x71, 0x3d, 0xf1, 0x7b, 0x7c, 0x2d, 0xac, 0xc8, 0x96,
	0x8b, 0xf4, 0x2a, 0xdb, 0x29, 0x77, 0x8a, 0x4c, 0x6c, 0x1d, 0x4f, 0x99, 0xb4, 0xd5, 0x75, 0x56,
	0xa8, 0x5a, 0x6f, 0xff, 0xbd, 0x08, 0x8d, 0x29, 0xbe, 0x79, 0x01, 0xfa, 0x30, 0xf7, 0x1e, 0x16,
	0xd7, 0xde, 0xc3, 0x2f, 0xb3, 0x5c, 0x48, 0x7a, 0xcc, 0xbb, 0x9b, 0x7c, 0x91, 0x9a, 0xb9, 0x9c,
	0x19, 0x06, 0xb4, 0xed, 0x39, 0x36, 0x49, 0x56, 0x72, 0xe5, 0x7a, 0xf4, 0x68, 0xda, 0x73, 0x36,
	0x0a, 0x12, 0x6f, 0x18, 0xcf, 0xb1, 0xe4, 0x28, 0x34, 0x40, 0x75, 0xef, 0xc0, 0x1c, 0xbd, 0x1a,
	0x76, 0x0b, 0xa4, 0x09, 0xb5, 0xf1, 0x68, 0x36, 0xc3, 0xee, 0xb2, 0x48, 0x5a, 0x50, 0xa7, 0xc3,
	0x17, 0xc3, 0x03, 0x73, 0x38, 0xe8, 0x96, 0xb0, 0x93, 0x3c, 0xd8, 0x9b, 0x0c, 0x46, 0x83, 0x3d,
	0x73, 0xd8, 0x2d, 0x6f, 0x4f, 0xa0, 0x9a, 0x58, 0xc2, 0xd1, 0xc9, 0x89, 0xd2, 0xf1, 0x0a, 0x97,
	0xa4, 0x0f, 0x5b, 0x78, 0x8c, 0xb4, 0x67, 0xf8, 0xf1, 0xfb, 0xbe, 0x9d, 0x26, 0xd0, 0xed, 0x57,
	0x00, 0x2b, 0xff, 0x60, 0xfc, 0x8a, 0xd8, 0x71, 0x98, 0x48, 0xf3, 0x22, 0x25, 0xd1, 0x21, 0x8c,
	0xf3, 0x90, 0xa7, 0x0e, 0x51, 0x04, 0xe2, 0xb1, 0x8c, 0x60, 0x2f, 0xa4, 0x83, 0x5a, 0x93, 0x46,
	0x08, 0x30, 0x8b, 0x4f, 0xc5, 0x85, 0x90, 0x6c, 0x29, 0xc8, 0x97, 0xd0, 0x5c, 0x65, 0x62, 0xd2,
	0xef, 0xbc, 0x2f, 0xb9, 0x69, 0x1e, 0x4d, 0xee, 0x41, 0xd9, 0x5d, 0xa4, 0xcd, 0x16, 0xb9, 0x7a,
	0x28, 0x8a, 0x62, 0xe3, 0xbb, 0x22, 0x6c, 0xa9, 0x3e, 0x94, 0x3c, 0x03, 0x10, 0xd9, 0xd6, 0xef,
	0x28, 0x24, 0xab, 0x6f, 0xa3, 0x39, 0x70, 0xbe, 0x62, 0x97, 0xae, 0x57, 0xb1, 0x6f, 0x03, 0xe0,
	0xcc, 0x64, 0x07, 0xb9, 0xcc, 0x6e, 0x68, 0x4e, 0x52, 0x4f, 0xb2, 0xb4, 0xaf, 0xac, 0xa7, 0xfd,
	0x23, 0xb8, 0x21, 0x02, 0x3b, 0x12, 0x8b, 0x50, 0x5a, 0x6e, 0xcc, 0x55, 0xab, 0xbf, 0x6a, 0xc4,
	0x49, 0x2a, 0x1b, 0x68, 0xd1, 0x58, 0x18, 0x16, 0x6c, 0xa9, 0xa6, 0x99, 0x3c, 0xd4, 0x73, 0xd0,
	0xe6, 0xce, 0x75, 0xd5, 0x58, 0x27, 0xc3, 0x4e, 0x07, 0x4a, 0x59, 0x35, 0x2b, 0x49, 0x81, 0x4e,
	0x73, 0xc2, 0x40, 0xb2, 0x40, 0xea, 0x99, 0x21, 0x25, 0x8d, 0x7f, 0x17, 0x81, 0x4c, 0x75, 0x2d,
	0xc3, 0x2e, 0x36, 0x99, 0x13, 0xf1, 0x56, 0xf2, 0x53, 0xff, 0xd5, 0x5b, 0xd1, 0x7f, 0x0f, 0xac,
	0xe6, 0x92, 0x87, 0xb0, 0xa5, 0x06, 0x06, 0x7d, 0x8b, 0x37, 0x36, 0xbc, 0x28, 0xec, 0xa8, 0x40,
	0x13, 0x10, 0xe9, 0x43, 0x8d, 0x27, 0x23, 0x91, 0xfa, 0xa0, 0xab, 0xf6, 0xf5, 0xc0, 0x74, 0x54,
	0xa0, 0x29, 0x10, 0x77, 0x50, 0x53, 0x83, 0xae, 0x99, 0x37, 0x36, 0xdd, 0x01, 0xee, 0xa0, 0x40,
	0xfb, 0x0d, 0xa8, 0x2d, 0x99, 0x10, 0xf6, 0x9c, 0x19, 0xff, 0x29, 0x41, 0xeb, 0xc0, 0xf7, 0x58,
	0x20, 0x67, 0xde, 0x3c, 0xb0, 0xfd, 0xff, 0xe3, 0x74, 0x5f, 0x40, 0x55, 0x28, 0x5d, 0x5d, 0x24,
	0xae, 0x74, 0xa9, 0x39, 0xf3, 0xbb, 0xc9, 0x0f, 0xd5, 0x1a, 0xe4, 0x10, 0x9a, 0x6a, 0xe2, 0x12,
	0x61, 0xcc, 0x9d, 0xb4, 0x87, 0xb8, 0xff, 0x3e, 0x03, 0xe8, 0x88, 0x99, 0x42, 0x53, 0x70, 0xb3,
	0x75, 0xde, 0x8b, 0x95, 0x75, 0x2f, 0xfe, 0x0e, 0xaa, 0xfa, 0x68, 0x6d, 0x68, 0xcc, 0x86, 0x93,
	0x81, 0x35, 0xd8, 0x33, 0xf7, 0xba, 0x05, 0x72, 0x13, 0xc8, 0x74, 0xef, 0x64, 0x36, 0xb4, 0xa6,
	0x27, 0xb3, 0x23, 0x6b, 0x38, 0x1e, 0x99, 0xa6, 0x1a, 0x61, 0x7b, 0x70, 0xe3, 0x64, 0xb2, 0x41,
	0x52, 0x22, 0x04, 0x3a, 0x07, 0xc7, 0x93, 0x5f, 0x8d, 0x0e, 0x33, 0x1e, 0x18, 0xf7, 0x00, 0x56,
	0x9f, 0x44, 0x1a, 0xb0, 0x35, 0x33, 0xb1, 0x34, 0xa9, 0x22, 0x46, 0x4f, 0x26, 0x6a, 0x18, 0x2e,
	0x7e, 0x3c, 0xdc, 0x58, 0xe7, 0x00, 0xaa, 0x07, 0x2f, 0x8f, 0x67, 0xc3, 0x41, 0xb7, 0x88, 0xf0,
	0xe3, 0xe9, 0x70, 0x82, 0x35, 0xaf, 0x84, 0x04, 0x0a, 0x90, 0x28, 0xa3, 0xcd, 0x21, 0xa5, 0xc7,
	0xb4, 0x5b, 0xf9, 0xf8, 0x1e, 0x54, 0xb0, 0xa1, 0xc2, 0x93, 0x8c, 0x26, 0x23, 0x73, 0xb4, 0x67,
	0x1e, 0xd3, 0x6e, 0x01, 0x49, 0x3a, 0x9c, 0x4d, 0x8f, 0x27, 0x03, 0x3c, 0xc0, 0x7e, 0xef, 0x1f,
	0x6f, 0x76, 0x8a, 0xdf, 0xbe, 0xd9, 0x29, 0x7e, 0xf7, 0x66, 0xa7, 0xf8, 0xe7, 0xb7, 0x3b, 0x85,
	0x6f, 0xdf, 0xee, 0x14, 0xfe, 0xf5, 0x76, 0xa7, 0x70, 0x5a, 0x55, 0x4f, 0xf3, 0x93, 0xff, 0x05,
	0x00, 0x00, 0xff, 0xff, 0x32, 0x96, 0xd8, 0x25, 0xe8, 0x12, 0x00, 0x00,
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Version) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultCounter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultCounter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultCounter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Err))
		i--
		dAtA[i] = 0x18
	}
	if m.Ok != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Ok))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SlidingCounter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlidingCounter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlidingCounter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Over_24Hr != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_24Hr))
		i--
		dAtA[i] = 0x50
	}
	if m.Over_12Hr != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_12Hr))
		i--
		dAtA[i] = 0x48
	}
	if m.Over_8Hr != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_8Hr))
		i--
		dAtA[i] = 0x40
	}
	if m.Over_4Hr != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_4Hr))
		i--
		dAtA[i] = 0x38
	}
	if m.Over_2Hr != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_2Hr))
		i--
		dAtA[i] = 0x30
	}
	if m.Over_1Hr != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_1Hr))
		i--
		dAtA[i] = 0x28
	}
	if m.Over_30M != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_30M))
		i--
		dAtA[i] = 0x20
	}
	if m.Over_15M != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_15M))
		i--
		dAtA[i] = 0x18
	}
	if m.Over_5M != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_5M))
		i--
		dAtA[i] = 0x10
	}
	if m.Over_1M != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Over_1M))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataGauge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataGauge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataGauge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InstBw != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.InstBw))
		i--
		dAtA[i] = 0x18
	}
	if m.CumPackets != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.CumPackets))
		i--
		dAtA[i] = 0x10
	}
	if m.CumBytes != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.CumBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PropertyTypes) > 0 {
		for iNdEx := len(m.PropertyTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PropertyTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIntrospection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventType_EventProperty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventType_EventProperty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventType_EventProperty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HasMultiple {
		i--
		if m.HasMultiple {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Runtime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Runtime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Runtime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EventTypes) > 0 {
		for iNdEx := len(m.EventTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EventTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIntrospection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.SendStateIntervalMs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.SendStateIntervalMs))
		i--
		dAtA[i] = 0x30
	}
	if m.KeepStaleDataMs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.KeepStaleDataMs))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Implementation) > 0 {
		i -= len(m.Implementation)
		copy(dAtA[i:], m.Implementation)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Implementation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EndpointPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndpointPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstMultiaddr) > 0 {
		i -= len(m.DstMultiaddr)
		copy(dAtA[i:], m.DstMultiaddr)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.DstMultiaddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SrcMultiaddr) > 0 {
		i -= len(m.SrcMultiaddr)
		copy(dAtA[i:], m.SrcMultiaddr)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.SrcMultiaddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Traffic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Traffic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Traffic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TrafficOut != nil {
		{
			size, err := m.TrafficOut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TrafficIn != nil {
		{
			size, err := m.TrafficIn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Streams) > 0 {
		for iNdEx := len(m.Streams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Streams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIntrospection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.StreamIds) > 0 {
		for iNdEx := len(m.StreamIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StreamIds[iNdEx])
			copy(dAtA[i:], m.StreamIds[iNdEx])
			i = encodeVarintIntrospection(dAtA, i, uint64(len(m.StreamIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserProvidedTags) > 0 {
		for iNdEx := len(m.UserProvidedTags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UserProvidedTags[iNdEx])
			copy(dAtA[i:], m.UserProvidedTags[iNdEx])
			i = encodeVarintIntrospection(dAtA, i, uint64(len(m.UserProvidedTags[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.RelayedOver != nil {
		{
			size := m.RelayedOver.Size()
			i -= size
			if _, err := m.RelayedOver.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Streams != nil {
		{
			size, err := m.Streams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.LatencyNs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.LatencyNs))
		i--
		dAtA[i] = 0x50
	}
	if m.Attribs != nil {
		{
			size, err := m.Attribs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Traffic != nil {
		{
			size, err := m.Traffic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Role != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x38
	}
	if m.Timeline != nil {
		{
			size, err := m.Timeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Endpoints != nil {
		{
			size, err := m.Endpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TransportId) > 0 {
		i -= len(m.TransportId)
		copy(dAtA[i:], m.TransportId)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.TransportId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Connection_ConnId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection_ConnId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnId != nil {
		i -= len(m.ConnId)
		copy(dAtA[i:], m.ConnId)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.ConnId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Connection_Conn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection_Conn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Conn != nil {
		{
			size, err := m.Conn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Connection_Timeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection_Timeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection_Timeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloseTs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.CloseTs))
		i--
		dAtA[i] = 0x18
	}
	if m.UpgradedTs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.UpgradedTs))
		i--
		dAtA[i] = 0x10
	}
	if m.OpenTs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.OpenTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Connection_Attributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection_Attributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection_Attributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Encryption) > 0 {
		i -= len(m.Encryption)
		copy(dAtA[i:], m.Encryption)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Encryption)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Multiplexer) > 0 {
		i -= len(m.Multiplexer)
		copy(dAtA[i:], m.Multiplexer)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Multiplexer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Stream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserProvidedTags) > 0 {
		for iNdEx := len(m.UserProvidedTags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UserProvidedTags[iNdEx])
			copy(dAtA[i:], m.UserProvidedTags[iNdEx])
			i = encodeVarintIntrospection(dAtA, i, uint64(len(m.UserProvidedTags[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.LatencyNs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.LatencyNs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Status != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.Timeline != nil {
		{
			size, err := m.Timeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Conn != nil {
		{
			size, err := m.Conn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Traffic != nil {
		{
			size, err := m.Traffic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Role != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Stream_ConnectionRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream_ConnectionRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream_ConnectionRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Connection != nil {
		{
			size := m.Connection.Size()
			i -= size
			if _, err := m.Connection.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Stream_ConnectionRef_Conn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream_ConnectionRef_Conn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Conn != nil {
		{
			size, err := m.Conn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Stream_ConnectionRef_ConnId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream_ConnectionRef_ConnId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnId != nil {
		i -= len(m.ConnId)
		copy(dAtA[i:], m.ConnId)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.ConnId)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Stream_Timeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream_Timeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream_Timeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloseTs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.CloseTs))
		i--
		dAtA[i] = 0x10
	}
	if m.OpenTs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.OpenTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DHT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OutgoingQueries != nil {
		{
			size, err := m.OutgoingQueries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.IncomingQueries != nil {
		{
			size, err := m.IncomingQueries.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buckets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIntrospection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StartTs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x18
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DHT_Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHT_Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHT_Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Beta != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Beta))
		i--
		dAtA[i] = 0x20
	}
	if m.DisjointPaths != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.DisjointPaths))
		i--
		dAtA[i] = 0x18
	}
	if m.Alpha != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Alpha))
		i--
		dAtA[i] = 0x10
	}
	if m.K != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.K))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DHT_PeerInDHT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHT_PeerInDHT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHT_PeerInDHT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AgeInBucket != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.AgeInBucket))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DHT_Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHT_Bucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHT_Bucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIntrospection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Cpl != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Cpl))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DHT_QueryGauge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHT_QueryGauge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHT_QueryGauge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x18
	}
	if m.Error != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Error))
		i--
		dAtA[i] = 0x10
	}
	if m.Success != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Success))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Subsystems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subsystems) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subsystems) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dht != nil {
		{
			size, err := m.Dht.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Connections) > 0 {
		for iNdEx := len(m.Connections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Connections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIntrospection(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *State) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *State) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *State) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnapshotDurationMs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.SnapshotDurationMs))
		i--
		dAtA[i] = 0x28
	}
	if m.StartTs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x20
	}
	if m.InstantTs != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.InstantTs))
		i--
		dAtA[i] = 0x18
	}
	if m.Traffic != nil {
		{
			size, err := m.Traffic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Subsystems != nil {
		{
			size, err := m.Subsystems.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ts != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Ts))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolDataPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolDataPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolDataPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size := m.Message.Size()
			i -= size
			if _, err := m.Message.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolDataPacket_State) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolDataPacket_State) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ProtocolDataPacket_Runtime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolDataPacket_Runtime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Runtime != nil {
		{
			size, err := m.Runtime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProtocolDataPacket_Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolDataPacket_Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ClientSignal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientSignal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientSignal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintIntrospection(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x22
	}
	if m.DataSource != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.DataSource))
		i--
		dAtA[i] = 0x18
	}
	if m.Signal != 0 {
		i = encodeVarintIntrospection(dAtA, i, uint64(m.Signal))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != nil {
		{
			size, err := m.Version.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIntrospection(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintIntrospection(dAtA []byte, offset int, v uint64) int {
	offset -= sovIntrospection(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovIntrospection(uint64(m.Version))
	}
	return n
}

func (m *ResultCounter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovIntrospection(uint64(m.Total))
	}
	if m.Ok != 0 {
		n += 1 + sovIntrospection(uint64(m.Ok))
	}
	if m.Err != 0 {
		n += 1 + sovIntrospection(uint64(m.Err))
	}
	return n
}

func (m *SlidingCounter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Over_1M != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_1M))
	}
	if m.Over_5M != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_5M))
	}
	if m.Over_15M != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_15M))
	}
	if m.Over_30M != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_30M))
	}
	if m.Over_1Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_1Hr))
	}
	if m.Over_2Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_2Hr))
	}
	if m.Over_4Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_4Hr))
	}
	if m.Over_8Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_8Hr))
	}
	if m.Over_12Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_12Hr))
	}
	if m.Over_24Hr != 0 {
		n += 1 + sovIntrospection(uint64(m.Over_24Hr))
	}
	return n
}

func (m *DataGauge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CumBytes != 0 {
		n += 1 + sovIntrospection(uint64(m.CumBytes))
	}
	if m.CumPackets != 0 {
		n += 1 + sovIntrospection(uint64(m.CumPackets))
	}
	if m.InstBw != 0 {
		n += 1 + sovIntrospection(uint64(m.InstBw))
	}
	return n
}

func (m *EventType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if len(m.PropertyTypes) > 0 {
		for _, e := range m.PropertyTypes {
			l = e.Size()
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *EventType_EventProperty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovIntrospection(uint64(m.Type))
	}
	if m.HasMultiple {
		n += 2
	}
	return n
}

func (m *Runtime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Implementation)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.KeepStaleDataMs != 0 {
		n += 1 + sovIntrospection(uint64(m.KeepStaleDataMs))
	}
	if m.SendStateIntervalMs != 0 {
		n += 1 + sovIntrospection(uint64(m.SendStateIntervalMs))
	}
	if len(m.EventTypes) > 0 {
		for _, e := range m.EventTypes {
			l = e.Size()
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *EndpointPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SrcMultiaddr)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.DstMultiaddr)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *Traffic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrafficIn != nil {
		l = m.TrafficIn.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.TrafficOut != nil {
		l = m.TrafficOut.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *StreamList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StreamIds) > 0 {
		for _, b := range m.StreamIds {
			l = len(b)
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *Connection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovIntrospection(uint64(m.Status))
	}
	l = len(m.TransportId)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Endpoints != nil {
		l = m.Endpoints.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Timeline != nil {
		l = m.Timeline.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovIntrospection(uint64(m.Role))
	}
	if m.Traffic != nil {
		l = m.Traffic.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Attribs != nil {
		l = m.Attribs.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.LatencyNs != 0 {
		n += 1 + sovIntrospection(uint64(m.LatencyNs))
	}
	if m.Streams != nil {
		l = m.Streams.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.RelayedOver != nil {
		n += m.RelayedOver.Size()
	}
	if len(m.UserProvidedTags) > 0 {
		for _, s := range m.UserProvidedTags {
			l = len(s)
			n += 2 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *Connection_ConnId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnId != nil {
		l = len(m.ConnId)
		n += 2 + l + sovIntrospection(uint64(l))
	}
	return n
}
func (m *Connection_Conn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Conn != nil {
		l = m.Conn.Size()
		n += 2 + l + sovIntrospection(uint64(l))
	}
	return n
}
func (m *Connection_Timeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenTs != 0 {
		n += 1 + sovIntrospection(uint64(m.OpenTs))
	}
	if m.UpgradedTs != 0 {
		n += 1 + sovIntrospection(uint64(m.UpgradedTs))
	}
	if m.CloseTs != 0 {
		n += 1 + sovIntrospection(uint64(m.CloseTs))
	}
	return n
}

func (m *Connection_Attributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Multiplexer)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.Encryption)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *Stream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovIntrospection(uint64(m.Role))
	}
	if m.Traffic != nil {
		l = m.Traffic.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Conn != nil {
		l = m.Conn.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Timeline != nil {
		l = m.Timeline.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovIntrospection(uint64(m.Status))
	}
	if m.LatencyNs != 0 {
		n += 2 + sovIntrospection(uint64(m.LatencyNs))
	}
	if len(m.UserProvidedTags) > 0 {
		for _, s := range m.UserProvidedTags {
			l = len(s)
			n += 2 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *Stream_ConnectionRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connection != nil {
		n += m.Connection.Size()
	}
	return n
}

func (m *Stream_ConnectionRef_Conn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Conn != nil {
		l = m.Conn.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}
func (m *Stream_ConnectionRef_ConnId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnId != nil {
		l = len(m.ConnId)
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}
func (m *Stream_Timeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenTs != 0 {
		n += 1 + sovIntrospection(uint64(m.OpenTs))
	}
	if m.CloseTs != 0 {
		n += 1 + sovIntrospection(uint64(m.CloseTs))
	}
	return n
}

func (m *DHT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.StartTs != 0 {
		n += 1 + sovIntrospection(uint64(m.StartTs))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	if m.IncomingQueries != nil {
		l = m.IncomingQueries.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.OutgoingQueries != nil {
		l = m.OutgoingQueries.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *DHT_Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K != 0 {
		n += 1 + sovIntrospection(uint64(m.K))
	}
	if m.Alpha != 0 {
		n += 1 + sovIntrospection(uint64(m.Alpha))
	}
	if m.DisjointPaths != 0 {
		n += 1 + sovIntrospection(uint64(m.DisjointPaths))
	}
	if m.Beta != 0 {
		n += 1 + sovIntrospection(uint64(m.Beta))
	}
	return n
}

func (m *DHT_PeerInDHT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovIntrospection(uint64(m.Status))
	}
	if m.AgeInBucket != 0 {
		n += 1 + sovIntrospection(uint64(m.AgeInBucket))
	}
	return n
}

func (m *DHT_Bucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cpl != 0 {
		n += 1 + sovIntrospection(uint64(m.Cpl))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	return n
}

func (m *DHT_QueryGauge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success != 0 {
		n += 1 + sovIntrospection(uint64(m.Success))
	}
	if m.Error != 0 {
		n += 1 + sovIntrospection(uint64(m.Error))
	}
	if m.Timeout != 0 {
		n += 1 + sovIntrospection(uint64(m.Timeout))
	}
	return n
}

func (m *Subsystems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Connections) > 0 {
		for _, e := range m.Connections {
			l = e.Size()
			n += 1 + l + sovIntrospection(uint64(l))
		}
	}
	if m.Dht != nil {
		l = m.Dht.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *State) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subsystems != nil {
		l = m.Subsystems.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Traffic != nil {
		l = m.Traffic.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.InstantTs != 0 {
		n += 1 + sovIntrospection(uint64(m.InstantTs))
	}
	if m.StartTs != 0 {
		n += 1 + sovIntrospection(uint64(m.StartTs))
	}
	if m.SnapshotDurationMs != 0 {
		n += 1 + sovIntrospection(uint64(m.SnapshotDurationMs))
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovIntrospection(uint64(m.Ts))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func (m *ProtocolDataPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *ProtocolDataPacket_State) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}
func (m *ProtocolDataPacket_Runtime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Runtime != nil {
		l = m.Runtime.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}
func (m *ProtocolDataPacket_Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}
func (m *ClientSignal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = m.Version.Size()
		n += 1 + l + sovIntrospection(uint64(l))
	}
	if m.Signal != 0 {
		n += 1 + sovIntrospection(uint64(m.Signal))
	}
	if m.DataSource != 0 {
		n += 1 + sovIntrospection(uint64(m.DataSource))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovIntrospection(uint64(l))
	}
	return n
}

func sovIntrospection(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIntrospection(x uint64) (n int) {
	return sovIntrospection(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultCounter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultCounter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultCounter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			m.Ok = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ok |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			m.Err = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Err |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlidingCounter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlidingCounter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlidingCounter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_1M", wireType)
			}
			m.Over_1M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_1M |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_5M", wireType)
			}
			m.Over_5M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_5M |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_15M", wireType)
			}
			m.Over_15M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_15M |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_30M", wireType)
			}
			m.Over_30M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_30M |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_1Hr", wireType)
			}
			m.Over_1Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_1Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_2Hr", wireType)
			}
			m.Over_2Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_2Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_4Hr", wireType)
			}
			m.Over_4Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_4Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_8Hr", wireType)
			}
			m.Over_8Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_8Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_12Hr", wireType)
			}
			m.Over_12Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_12Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over_24Hr", wireType)
			}
			m.Over_24Hr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over_24Hr |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataGauge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataGauge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataGauge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumBytes", wireType)
			}
			m.CumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CumBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumPackets", wireType)
			}
			m.CumPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CumPackets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstBw", wireType)
			}
			m.InstBw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstBw |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropertyTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PropertyTypes = append(m.PropertyTypes, &EventType_EventProperty{})
			if err := m.PropertyTypes[len(m.PropertyTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventType_EventProperty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventProperty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventProperty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EventType_EventProperty_PropertyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMultiple", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMultiple = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Runtime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Runtime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Runtime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implementation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Implementation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepStaleDataMs", wireType)
			}
			m.KeepStaleDataMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepStaleDataMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendStateIntervalMs", wireType)
			}
			m.SendStateIntervalMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendStateIntervalMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventTypes = append(m.EventTypes, &EventType{})
			if err := m.EventTypes[len(m.EventTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcMultiaddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcMultiaddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMultiaddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstMultiaddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Traffic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Traffic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Traffic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficIn == nil {
				m.TrafficIn = &DataGauge{}
			}
			if err := m.TrafficIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrafficOut == nil {
				m.TrafficOut = &DataGauge{}
			}
			if err := m.TrafficOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamIds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamIds = append(m.StreamIds, make([]byte, postIndex-iNdEx))
			copy(m.StreamIds[len(m.StreamIds)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, &Stream{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransportId = append(m.TransportId[:0], dAtA[iNdEx:postIndex]...)
			if m.TransportId == nil {
				m.TransportId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoints == nil {
				m.Endpoints = &EndpointPair{}
			}
			if err := m.Endpoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeline == nil {
				m.Timeline = &Connection_Timeline{}
			}
			if err := m.Timeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traffic == nil {
				m.Traffic = &Traffic{}
			}
			if err := m.Traffic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attribs == nil {
				m.Attribs = &Connection_Attributes{}
			}
			if err := m.Attribs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyNs", wireType)
			}
			m.LatencyNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatencyNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Streams == nil {
				m.Streams = &StreamList{}
			}
			if err := m.Streams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.RelayedOver = &Connection_ConnId{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Connection{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RelayedOver = &Connection_Conn{v}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProvidedTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProvidedTags = append(m.UserProvidedTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection_Timeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTs", wireType)
			}
			m.OpenTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradedTs", wireType)
			}
			m.UpgradedTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradedTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTs", wireType)
			}
			m.CloseTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection_Attributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplexer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Multiplexer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encryption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traffic == nil {
				m.Traffic = &Traffic{}
			}
			if err := m.Traffic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conn == nil {
				m.Conn = &Stream_ConnectionRef{}
			}
			if err := m.Conn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeline == nil {
				m.Timeline = &Stream_Timeline{}
			}
			if err := m.Timeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyNs", wireType)
			}
			m.LatencyNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatencyNs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProvidedTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserProvidedTags = append(m.UserProvidedTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream_ConnectionRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Connection{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Connection = &Stream_ConnectionRef_Conn{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Connection = &Stream_ConnectionRef_ConnId{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream_Timeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTs", wireType)
			}
			m.OpenTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTs", wireType)
			}
			m.CloseTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &DHT_Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, &DHT_Bucket{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingQueries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncomingQueries == nil {
				m.IncomingQueries = &DHT_QueryGauge{}
			}
			if err := m.IncomingQueries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingQueries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutgoingQueries == nil {
				m.OutgoingQueries = &DHT_QueryGauge{}
			}
			if err := m.OutgoingQueries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHT_Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alpha", wireType)
			}
			m.Alpha = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alpha |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisjointPaths", wireType)
			}
			m.DisjointPaths = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisjointPaths |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beta", wireType)
			}
			m.Beta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Beta |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHT_PeerInDHT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerInDHT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerInDHT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DHT_PeerInDHT_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgeInBucket", wireType)
			}
			m.AgeInBucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgeInBucket |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHT_Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpl", wireType)
			}
			m.Cpl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &DHT_PeerInDHT{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHT_QueryGauge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryGauge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryGauge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			m.Success = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Success |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subsystems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subsystems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subsystems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connections = append(m.Connections, &Connection{})
			if err := m.Connections[len(m.Connections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dht", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dht == nil {
				m.Dht = &DHT{}
			}
			if err := m.Dht.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsystems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subsystems == nil {
				m.Subsystems = &Subsystems{}
			}
			if err := m.Subsystems.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traffic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traffic == nil {
				m.Traffic = &Traffic{}
			}
			if err := m.Traffic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstantTs", wireType)
			}
			m.InstantTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstantTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotDurationMs", wireType)
			}
			m.SnapshotDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotDurationMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &EventType{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolDataPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolDataPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolDataPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &State{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &ProtocolDataPacket_State{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Runtime{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &ProtocolDataPacket_Runtime{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Event{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &ProtocolDataPacket_Event{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientSignal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientSignal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientSignal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Version == nil {
				m.Version = &Version{}
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signal", wireType)
			}
			m.Signal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Signal |= ClientSignal_Signal(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSource", wireType)
			}
			m.DataSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSource |= ClientSignal_DataSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIntrospection
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIntrospection
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIntrospection(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIntrospection
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIntrospection(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIntrospection
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIntrospection
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIntrospection
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIntrospection
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIntrospection
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIntrospection        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIntrospection          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIntrospection = fmt.Errorf("proto: unexpected end of group")
)
